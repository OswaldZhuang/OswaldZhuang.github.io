<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oswald</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-27T15:16:09.425Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Oswald Zhuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring对bean的加载顺序（2）</title>
    <link href="http://yoursite.com/2020/02/27/Spring%E5%AF%B9bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/27/Spring对bean的加载顺序（2）/</id>
    <published>2020-02-26T20:52:47.000Z</published>
    <updated>2020-02-27T15:16:09.425Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们说到包扫描时候类资源是如何被spring读取进来并包装为Resource返回<br>然后再由MetadataReader读取其中注解信息（暂时略过）最终生成BeanDefinition的<br>而实际上BeanDefinition转化为实际的bean之前还需要被注册进BeanFactory中，<br>接下来我们讨论一下注册的过程</p><p>还记得上一篇文章的第二个代码片段吗，我只列出了前半段获取BeanDefinition的过程，现列出后半段<br>篇幅很长但有用的信息很多<br>1处：处理@Scope注解<br>2处：生成bean的名字<br>3处：设置bean为autowire模式<br>4处：处理@Lazy，@Primary，@DependsOn，@Role，@Description这样的公共注解<br>5处：设置代理模式（如果有的话）<br>6处：向BeanFactory注册BeanDefinition</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ClassPathBeanDefinitionScanner</span><br><span class="line"></span><br><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line">        ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); // 1</span><br><span class="line">        candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line"></span><br><span class="line">        String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); // 2</span><br><span class="line"></span><br><span class="line">        if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">            postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); // 3</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">            AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); // 4</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">            BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">            definitionHolder =</span><br><span class="line">                    AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); // 5</span><br><span class="line">            beanDefinitions.add(definitionHolder);</span><br><span class="line">            registerBeanDefinition(definitionHolder, this.registry); //6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一步步进入到上述6处的代码中，该方法做两件事情：向BeanFactory注册BeanDefinition（1）和别名Alias（2） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionReaderUtils</span><br><span class="line"></span><br><span class="line">public static void registerBeanDefinition(</span><br><span class="line">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 1</span><br><span class="line">    ... // 2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步深入上述1处的代码，<br>省略的注释1处的代码是”已经存在同名的BeanDefinition”以及”创建bean的过程已经开始的时候”的情况的处理<br>我们可以先不看<br>剩下的就是BeanDefinition第一次被注册进来的逻辑：<br>很简单，不是吗，维护两个主要的数据结构：Map类型的bean名字和定义的映射；顺序存储bean名字的List</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory</span><br><span class="line"></span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    ... // 1</span><br><span class="line"></span><br><span class="line">    this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    this.beanDefinitionNames.add(beanName);</span><br><span class="line">    this.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回想一下，ClassPathBeanDefinitionScanner在扫描给定路径下类文件后转化为Resource是按照文件名的字典序排序的，<br>然后遍历的将其注册到BeanFactory中，所以List结构的bean名字顺序即给定路径下的文件字典序<br>而ApplicationContext在真正创建bean的时候又是遍历存有bean名字的链表（可见另一篇文章 &lt;Spring bean的获取过程&gt;）<br>因此spring加载给定路径下bean的大致顺序为文件名的字典序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前我们说到包扫描时候类资源是如何被spring读取进来并包装为Resource返回&lt;br&gt;然后再由MetadataReader读取其中注解信息（暂时略过）最终生成BeanDefinition的&lt;br&gt;而实际上BeanDefinition转化为实际的bean之前还需要被注册
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="spring" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring对bean的加载顺序（1）</title>
    <link href="http://yoursite.com/2020/02/23/Spring%E5%AF%B9bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/23/Spring对bean的加载顺序（1）/</id>
    <published>2020-02-23T15:58:21.000Z</published>
    <updated>2020-02-26T12:51:46.011Z</updated>
    
    <content type="html"><![CDATA[<p>spring的容器会通过以下方式获取bean：<br>    1.xml<br>    2.Java的Configuration（@Bean）<br>    3.@ComponentScan的包下面的各个类（@Component修饰）<br>    *看到这里可能会疑惑为什么没有@Service，@Repository，@Controller等等，<br>     实际上，如果仔细去看这些注解的话，可以知道这些注解均被@Component修饰，<br>     事实就是spring只认@Component<br>读取这些bean的类信息，将其封装为BeanDefinition，并通过某种方式排序，为后面的refresh阶段作准备。</p><p>现在，我们就来研究这一过程。</p><p>如果我们去看ApplicationContext的类实现结构，我们可以发现，每一种不同的实现其实是基于bean的来源，比如<br>ClassPathXmlApplicationContext的bean来源就是class path下的xml文件<br>AnnotationConfigApplicationContext的bean来源就是注解修饰的类<br>等等</p><p>由于现在很多时候我们都不用xml这种古老的方式了，故我们分析下第二种：注解方式</p><p>首先看下它的众多构造函数之一：</p><p>可以看到构造函数中不仅传入了BeanFactory，还新增了两个成员，从名字就可以知道他们的作用：<br>reader – 读取java Configuration类中定义的@Bean修饰成员<br>scanner – 扫描class path下面的@Component修饰的类并转化为BeanDefinition</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) &#123;</span><br><span class="line">super(beanFactory);</span><br><span class="line">this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line">this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进到doScan方法中，可以看到，其传入包路径，返回BeanDefinitionHolder，这正是我们需要关注研究的内容<br>1处的代码着重会读取class文件内容以及生成相应的bean定义<br>2处的代码会设置相关的scope信息及一些后续处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClassPathBeanDefinitionScanner</span><br><span class="line"></span><br><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    for (String basePackage : basePackages) &#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 1</span><br><span class="line">        ... // 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一步步跳进上面1处的代码中，可得如下代码片段<br>第一步会根据传来的包名来获取该路径下所有的Resource，为路径下的class文件，jar包内的class文件等等，<br>其中packageSearchPath的值为classpath<em>:/&lt;传入的路径&gt;/**/</em>.class，即整个类路径下的所有目录下的class文件<br>第二步，将这些resource的MateData（各种spring注解的内容）解析出来<br>本文暂时不会关心元数据的解析过程，我们还是看resource是如何读进来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ClassPathScanningCandidateComponentProvider</span><br><span class="line"></span><br><span class="line">private Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) &#123;</span><br><span class="line"></span><br><span class="line">    Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); // 1</span><br><span class="line">    </span><br><span class="line">    for (Resource resource : resources) &#123;</span><br><span class="line">        MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // 2</span><br><span class="line">        if (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">            ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">            sbd.setResource(resource);</span><br><span class="line">            sbd.setSource(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳进上面1中代码<br>1处代码负责解析出根目录的resource（这里其实包含的是路径，即返回URLResource，而该过程采用ClassLoader完成），<br>比如传入的package是com.example.a，那么rootDirResource的路径就是&lt;绝对类路径&gt;/com/example/a/<br>2处代码返回本身，供扩展使用<br>接下来，会判断URL类型，比如VFS，jar，否则采用3处的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PathMatchingResourcePatternResolver</span><br><span class="line"></span><br><span class="line">protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123;</span><br><span class="line">    String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">    Resource[] rootDirResources = getResources(rootDirPath); // 1</span><br><span class="line">    </span><br><span class="line">    for (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">        rootDirResource = resolveRootDirResource(rootDirResource); // 2</span><br><span class="line">        ...</span><br><span class="line">        result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); // 3</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入上面3的代码，可以很清楚的看到，是通过File的方式查找根目录下的”资源”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PathMatchingResourcePatternResolver</span><br><span class="line"></span><br><span class="line">protected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)</span><br><span class="line">throws IOException &#123;</span><br><span class="line">    File rootDir = rootDirResource.getFile().getAbsoluteFile();</span><br><span class="line">    return doFindMatchingFileSystemResources(rootDir, subPattern); // 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一步步进入到2中代码里去<br>可以看到，该方法<br>首先将当前目录下的文件列出来（1处），随后对他们进行排序（2处），而排序的规则是”字典序”<br>随后，遍历这些文件，对目录类型的文件递归的调用此方法（3处），对于普通文件，加入到结果中（4处）<br>比如你传入的路径为com.example，该路径下有目录A，文件D，而A下面有B，C两个文件<br>那么最终result的结果便是A，B，C，D<br>这些File会被包装为FileSystemResource最终返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PathMatchingResourcePatternResolver</span><br><span class="line"></span><br><span class="line">protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set&lt;File&gt; result) throws IOException &#123;</span><br><span class="line">    File[] dirContents = dir.listFiles(); // 1</span><br><span class="line">    Arrays.sort(dirContents); // 2</span><br><span class="line">    </span><br><span class="line">    for (File content : dirContents) &#123;</span><br><span class="line">        if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;/&quot;)) &#123;</span><br><span class="line">            doRetrieveMatchingFiles(fullPattern, content, result); // 3</span><br><span class="line">        &#125;</span><br><span class="line">        if (getPathMatcher().match(fullPattern, currPath)) &#123;</span><br><span class="line">            result.add(content); // 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;spring的容器会通过以下方式获取bean：&lt;br&gt;    1.xml&lt;br&gt;    2.Java的Configuration（@Bean）&lt;br&gt;    3.@ComponentScan的包下面的各个类（@Component修饰）&lt;br&gt;    *看到这里可能会疑惑为什
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="spring" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring bean的获取过程</title>
    <link href="http://yoursite.com/2020/02/01/Spring%20bean%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/01/Spring bean的获取过程/</id>
    <published>2020-02-01T11:16:37.000Z</published>
    <updated>2020-02-23T11:50:24.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Spring获取bean实例是通过BeanFactory#getBean方法</p></blockquote><p>getBean不仅仅是从容器中取出已有的bean，如果容器中还不存在该bean，getBean还会将其实例化再返回。事实上，spring容器启动<br>的时候bean的实例化正是通过getBean完成的。</p><p>现分析容器初始化时bean的实例化过程</p><p>省略掉refresh时前后阶段的各种准备与事件发布过程，非懒加载的bean的初始化（包括实例化，代理等）入口即下面这句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext</span><br><span class="line"></span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">    ...</span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳进去，前面的代码用于初始化特定类型的bean，比如ConversionService，LoadTimeWeaverAware，我们不必关系，只看最后一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext</span><br><span class="line"></span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    ...</span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看这个方法，可以看到，实例化bean的时候是遍历bean的名字，然后依次实例化，对于FactoryBean来说，其名字由bean名与特殊前缀构成，<br>而这个前缀是’&amp;’符号，随后，统一采用getBean来实例化每个bean，geBean简单的调用doGetBean方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (String beanName : beanNames) &#123;</span><br><span class="line">        if (isFactoryBean(beanName)) &#123;</span><br><span class="line">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGetBean方法比较长也比较复杂，这里提取了一些关键的步骤依次分析，首先通过getSingleton获取缓存中是否已经存在，<br>具体来说，已经创建出来的bean会存在singletonObjects，earlySingletonObjects，singletonFactories（用于FactoryBean）<br>（以上皆为BeanFactory成员变量）中。<br>如果存在的话直接返回。<br>如果不存在的话，<br>首先校验当前线程是否正在创建该bean且是prototype类型，如果是，那么可以认为是产生循环依赖，抛出异常（为什么这么做？）<br>然后遍历其dependsOn，即@DependsOn，并依次实例化这些”依赖”，并监测期间是否存在循环依赖（具体可见步骤3里for里面的代码）<br>（和一般bean的循环依赖略有不同，@DependsOn不允许出现A依赖B，B依赖A的情况，一般bean的循环依赖后面会讲）<br>最后就是bean的实例化了，实际上真正创建bean的就是传入的lambda中那个createBean方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanFactory</span><br><span class="line"></span><br><span class="line">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line">    Object sharedInstance = getSingleton(beanName); // 1</span><br><span class="line">    if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (isPrototypeCurrentlyInCreation(beanName)) &#123; // 2</span><br><span class="line">            throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (String dep : dependsOn) &#123;...&#125; // 3</span><br><span class="line">        </span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return createBean(beanName, mbd, args); // 4</span><br><span class="line">            &#125;</span><br><span class="line">            catch (BeansException ex) &#123;</span><br><span class="line">                destroySingleton(beanName);</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从createBean开始</p><p>剔除不那么关注的代码，其实创建bean的主要过程就两个，1处的代码通过调用各种BeanPostProcessor创建bean，具体来说，<br>实例化是由InstantiationAwareBeanPostProcessor完成（AOP中还会有他的身影），实例化后再由其他BeanPostProcessor后置处理<br>假如说就是很普通的我们声明的bean，那么就走2处代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">throws BeanCreationException &#123;</span><br><span class="line">        ...</span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse); // 1</span><br><span class="line">        if (bean != null) &#123;</span><br><span class="line">            return bean;</span><br><span class="line">        &#125;</span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args); // 2</span><br><span class="line">        return beanInstance;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doCreateBean的主要步骤如下，实际上，bean创建的时候返回的是BeanWrapper的包装对象，步骤一bean对象完成了真正的实例化，<br>包括通过构造函数（有参数，无参数），工厂方法，该步骤后续会详讲。<br>步骤二将创建出的bean缓存在singletonObjects，回忆一下对doGetBean方法的解读，虽然bean还没有完全创建结束（比如属性的autowire还没开始），<br>但是先将其缓存起来，防止了循环依赖的问题（没有缓存判断，循环依赖下创建bean将是死循环）<br>步骤三，进行bean属性的自动绑定（autowire）和其他一些动作<br>步骤四，实现各种Aware接口以及InitializingBean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line"></span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span><br><span class="line">throws BeanCreationException &#123;</span><br><span class="line">    BeanWrapper instanceWrapper = createBeanInstance(beanName, mbd, args); // 1</span><br><span class="line"></span><br><span class="line">    final Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line"></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); // 2</span><br><span class="line">    </span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper); // 3</span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd); // 4</span><br><span class="line">    </span><br><span class="line">    return exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳到createBeanInstance方法，无论条件如何，创建BeanWrapper的方式有以下几种</p><ol><li>通过Supplier</li><li>通过工厂方法（比如Spring Configuration申明的bean）</li><li>带参数的构造函数自动绑定</li><li>构造函数默认参数直接创建<br>这几种构造方式后面将会详细分析<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line"></span><br><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return obtainFromSupplier(instanceSupplier, beanName); // 1</span><br><span class="line">    ...</span><br><span class="line">    return instantiateUsingFactoryMethod(beanName, mbd, args); // 2</span><br><span class="line">    ...</span><br><span class="line">    return autowireConstructor(beanName, mbd, null, null); // 3</span><br><span class="line">    ...</span><br><span class="line">    return instantiateBean(beanName, mbd); // 4</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>回到前面的populateBean方法，前面会通过InstantiationAwareBeanPostProcessor（如果有的话）做一些处理，<br>然后根据BeanDefinition中设置的自动绑定模式来决定如何进行自动绑定，也就是1和2的代码选其一执行之，<br>那么执行这两步（其中之一）之后就真的把依赖注入到了bean中呢？答案是否定的，执行完1/2步骤的结果会被设置到PropertyValues对象中，<br>再经由步骤3设置进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line"></span><br><span class="line">protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123;</span><br><span class="line">    ...</span><br><span class="line">    autowireByName(beanName, mbd, bw, newPvs); // 1</span><br><span class="line">    ...</span><br><span class="line">    autowireByType(beanName, mbd, bw, newPvs); // 2</span><br><span class="line">    ...</span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs); // 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以autowireByName为例，实现是比较简单的，遍历属性名，然后递归调用getBean获取bean，再将其添加到PropertyValues，最后<br>将依赖关系注册到dependenciesForBeanMap（Map&lt;String, Set<String>&gt;类型，key是bean名字，value是依赖集合）</String></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line"></span><br><span class="line">protected void autowireByName(</span><br><span class="line">String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123;</span><br><span class="line">    for (String propertyName : propertyNames) &#123;</span><br><span class="line">        Object bean = getBean(propertyName);</span><br><span class="line">        pvs.add(propertyName, bean);</span><br><span class="line">        registerDependentBean(propertyName, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireByType方法比较复杂，限于篇幅，这里只给结果，日后有时间再议：</p><p>再看applyPropertyValues，前面是一些关于PropertyValue的转化操作，<br>而真正设置bean属性的是其setPropertyValues方法，这个方法非常长，简单的说，是通过反射调用writeMethod写入属性<br>后面章节会详细说明其过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory</span><br><span class="line"></span><br><span class="line">protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) &#123;</span><br><span class="line">    ...</span><br><span class="line">    bw.setPropertyValues(new MutablePropertyValues(deepCopy));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如是，获得bean完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Spring获取bean实例是通过BeanFactory#getBean方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;getBean不仅仅是从容器中取出已有的bean，如果容器中还不存在该bean，getBean还会将其实例化再返回。事实上，sp
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="spring" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis的缓存机制</title>
    <link href="http://yoursite.com/2020/02/01/Mybatis%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/01/Mybatis的缓存机制/</id>
    <published>2020-02-01T11:16:37.000Z</published>
    <updated>2020-02-23T11:49:24.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Mybatis的缓存有两种：一级缓存，二级缓存。</p></blockquote><p>一级缓存的作用域为SqlSession，二级缓存的作用域为某条Sql（或者准确的说是MappedStatement）</p><p>那么他们的区别和工作流程是怎么样的呢？</p><p>###一级缓存<br>从前面的分析中我们知道，在进行查询的时候，Mybatis会调用SqlSession进而调用Executor来执行sql语句。<br>而一切Executor的基础类是BaseExecutor（这也是个模板类），在BaseExecutor中有这么一段代码<br>其中localCache就是所谓的一级缓存，先从缓存中拿数据，拿不到再查库，这是典型的写法，注意到这里缓存的key是CacheKey，<br>这个key是如何被计算出来的，后面会详解<br>其中handleLocallyCachedOutputParameters的处理事针对存储过程，在此不做讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BaseExecutor</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, </span><br><span class="line">                         CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;</span><br><span class="line">    if (list != null) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而查库的时候，也是按照标准的写法，首先在缓存中写入一个占位符（为啥要这样？），然后查库，最后清除占位符再把实际数据写进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BaseExecutor</span><br><span class="line"></span><br><span class="line">private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, </span><br><span class="line">                                      RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, </span><br><span class="line">                                      BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    try &#123;</span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，看看一级缓存的具体实现，其实例化是在Executor的构造函数中，Perpetual是永久的意思，表明它是一直存在的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected BaseExecutor(Configuration configuration, Transaction transaction) &#123;</span><br><span class="line">    ...</span><br><span class="line">    this.localCache = new PerpetualCache(&quot;LocalCache&quot;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看其实现，非常简单，就是一个HashMap，所以倒过来，我们可以想想，Executor非线程安全（因为Cache），SqlSession也非线程安全（因为Executor）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class PerpetualCache implements Cache &#123;</span><br><span class="line">    private final Map&lt;Object, Object&gt; cache = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个问题，既然运用了缓存，那么必然存在脏读脏写的问题，如果另一个线程更新了数据会如何呢？<br>实际上，在更新操作发生之前，就会对缓存进行清除，而Mybatis的做法是：全部清除<br>clearLocalCache调用的就是PerpetualCache中HashMap的clear方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseExecutor</span><br><span class="line"></span><br><span class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    return doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到第一个问题，CacheKey是如何被计算出来的，在真正的query之前，会通过createCacheKey计算出CacheKey对象，<br>简单的看看这个方法，key值和MappedStatement的Id（类名.方法名），RowBounds，sql语句，value，Environment的Id有关，而value的值和传入参数相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BaseExecutor</span><br><span class="line"></span><br><span class="line">public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123;</span><br><span class="line">    CacheKey cacheKey = new CacheKey();</span><br><span class="line">    cacheKey.update(ms.getId());</span><br><span class="line">    cacheKey.update(rowBounds.getOffset());</span><br><span class="line">    cacheKey.update(rowBounds.getLimit());</span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    cacheKey.update(value);</span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    </span><br><span class="line">    return cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看key的update方法，该方法的目标就是计算出key的hash值（想想HashMap的put方法实现），具体是将（传入参数的hash值乘以<br>当前已经update的对象的个数）然后加上（CacheKey的hash值乘以multiplier（默认37）的值）<br>这么做我想是为了尽量减少哈希的冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CacheKey</span><br><span class="line"></span><br><span class="line">public void update(Object object) &#123;</span><br><span class="line">    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line"></span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line"></span><br><span class="line">    updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###二级缓存</p><p>之前有提到，BaseExecutor中有个子类是CachingExecutor，这就是运用二级缓存应用的地方，我们首先找到其query方法，把运用缓存那一段抽出来<br>可以看出，这个Cache并不是Executor的成员，而是MappedStatement的。然而，对象的提取并不是直接从这个cache拿出来的，而是通过<br>TransactionalCacheManager（代码中的tcm）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CachingExecutor</span><br><span class="line"></span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, </span><br><span class="line">                         CacheKey key, BoundSql boundSql) throws SQLException &#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); </span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察TransactionalCacheManager的结构，其维护了Cache和TransactionalCache对，真正的操作发生在TransactionalCache上<br>这里或许有个疑问，那就是为什么设置两个cache？其实这里是一个巧妙的做法，作为key的Cache是缓存的具体实现，而作为value的TransactionalCache是对<br>key的封装，并提供一个统一的与事务相关的功能。观察getTransactionalCache方法的实现，传入的cache实际是TransactionalCache的构造函数的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionalCacheManager &#123;</span><br><span class="line">    private final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Object getObject(Cache cache, CacheKey key) &#123;</span><br><span class="line">        return getTransactionalCache(cache).getObject(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TransactionalCache getTransactionalCache(Cache cache) &#123;</span><br><span class="line">        return transactionalCaches.computeIfAbsent(cache, TransactionalCache::new);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看TransactionalCache的实现，该类维护了很多成员变量，这里的delegate即上述真正的实现类，entriesToAddOnCommit是事务提交时<br>才会添加缓存的对象，entriesMissedInCache是未命中缓存的key集合。<br>可以看到，putObject并没有把待缓存对象直接放入delegate中，而是放入了entriesToAddOnCommit，同时getObject在delegate中未找到时会把key<br>添加到entriesMissedInCache。那么问题来了，待缓存对象什么时候能添加到真正的delegate中呢？答案是调用其commit方法时。<br>commit方法（这里只截取了部分代码）调用了flushPendingEntries，该方法会遍历entriesToAddOnCommit，然后再通过delegate添加缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionalCache implements Cache &#123;</span><br><span class="line"></span><br><span class="line">    public TransactionalCache(Cache delegate) &#123;</span><br><span class="line">        this.delegate = delegate;</span><br><span class="line">        this.clearOnCommit = false;</span><br><span class="line">        this.entriesToAddOnCommit = new HashMap&lt;&gt;();</span><br><span class="line">        this.entriesMissedInCache = new HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void putObject(Object key, Object object) &#123;</span><br><span class="line">        entriesToAddOnCommit.put(key, object);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object getObject(Object key) &#123;</span><br><span class="line">        Object object = delegate.getObject(key);</span><br><span class="line"></span><br><span class="line">        if (object == null) &#123;</span><br><span class="line">              entriesMissedInCache.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void commit() &#123;</span><br><span class="line">        flushPendingEntries();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，TransactionalCache的commit又是什么时候调用的呢？答案是通过TransactionalCacheManager的commit，而该commit<br>是由Executor的commit调用，而Executor的commit最终由SqlSession调用。<br>可以看出，二级缓存是通过事务提交而生效的。</p><p>尽管Mybatis中的Cache的实现看起来多种多样，但这些所谓的”实现”都只是装饰类，仅仅是用名称表明功能而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Mybatis的缓存有两种：一级缓存，二级缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一级缓存的作用域为SqlSession，二级缓存的作用域为某条Sql（或者准确的说是MappedStatement）&lt;/p&gt;
&lt;p&gt;那么他们的区别和工作流程
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis是如何解析结果集的</title>
    <link href="http://yoursite.com/2020/01/28/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9A%84/"/>
    <id>http://yoursite.com/2020/01/28/Mybatis是如何解析结果集的/</id>
    <published>2020-01-27T16:43:25.000Z</published>
    <updated>2020-05-23T08:44:11.452Z</updated>
    
    <content type="html"><![CDATA[<p>2020年春节这几天，全国赶上了严重的冠状病毒疫情，疫情中心武汉封城，许多城市进行交通管制，没有特殊情况尽量不要出门。<br>武汉加油。</p><p>在家无聊，还是更新下博客吧。</p><p>前面说到了，Mybatis在初始化解析注解（xml）阶段，会将结果集到对象的映射解析成为ResultMap并注册到Configuration中。<br>在执行完sql语句（Statement）时，StatementHandler会负责将结果集映射到我们需要的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatementHandler</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    return resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳进最后一行，是DefaultResultSetHandler的handleResultSets方法，这是个比较长的方法，大部分代码是关于多个ResultMap的处理，<br>至于这些ResultMap是如何生成以及如何使用，后面章节会细讲。如果仔细观察的话，会发现真正用在处理结果集的只有一行。而return那一行是<br>将解析出来的对象展开为list形式。假如说我们什么结果也没有查询出来，那么该方法返回的是什么呢？整体的看下这个方法，可以知道是空的ArrayList。<br>但是需要注意的是：如果mapper的返回值是单个对象，那么db中没有数据的时候，返回值是null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultResultSetHandler</span><br><span class="line"></span><br><span class="line">public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123;</span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, null);</span><br><span class="line">    return collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳进上面那个handleResultSet方法，仍然只关注重点，我们或许会感到奇怪，这个方法是void方法，最终生成的对象跑到哪里去了呢？实际上，有两个<br>途径，一个是传入参数multipleResults，另一个是ResultHandler，ResultHandler是DefaultResultSetHandler的一个成员，<br>而ResultHandler中正是保存了最终生成的结果（List或者Map，对应Mybatis中的两个默认实现DefaultResultHandler，DefaultMapResultHandler）。<br>最终，映射结果集每行数据的任务就落到了handleRowValues方法上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultResultSetHandler</span><br><span class="line"></span><br><span class="line">private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, </span><br><span class="line">                             List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走进handleResultSet方法，上面的是嵌套查询的映射，下面是简单映射，即一列数据对应一条属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultResultSetHandler</span><br><span class="line"></span><br><span class="line">public void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, </span><br><span class="line">                            RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123;</span><br><span class="line">    if (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">        handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是来看看简单映射，大致分为三步，首先获取Discriminator中的ResultMap，假如说没有Discriminator，那么返回之前的ResultMap<br>（也就是传入参数）。然后得到真正我们需要的对象。最后，将得到的对象存到ResultContext和ResultHandler中。<br>那么第二步肯定是我们关注的重点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultResultSetHandler</span><br><span class="line"></span><br><span class="line">private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, </span><br><span class="line">                                               RowBounds rowBounds, ResultMapping parentMapping) &#123;</span><br><span class="line">    while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">        ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);</span><br><span class="line">        Object rowValue = getRowValue(rsw, discriminatedResultMap, null);</span><br><span class="line">        storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将代码缩减一下，可以得到下面几个比较关键的步骤，其中createResultObject会将所需对象以各种形式创建出来，这一点后面会详细说明，<br>随后，假如该对象没有对应的TypeHandler，那么新建一个MetaObject，注意到，MetaObject是所需对象的一个包装对象，目的是提供统一<br>的接口以设置映射对象的属性（比如说通过无参数构造器创建了User对象，那么其中的name，age等属性则通过MetaObject设置）<br>下面，如果设置自动映射的话则采取自动映射（默认情况下该未true），最后采取属性映射。<br>值得说明的是，applyAutomaticMapping是用于没有显示指明映射关系的列，他与applyPropertyMappings的作用是一致的，即通过<br>注册的TypeHandler进行转换，然后通过MetaObject的setValue方法为目标对象设置属性值。<br>我们的重点还是放到第一行，对象的构造。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultResultSetHandler</span><br><span class="line"></span><br><span class="line">private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException &#123;</span><br><span class="line">    Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">    final MetaObject metaObject = configuration.newMetaObject(rowValue);</span><br><span class="line">    boolean foundValues = this.useConstructorMappings;</span><br><span class="line">    if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">        if (shouldApplyAutomaticMappings(resultMap, false)) &#123;</span><br><span class="line">            foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues;</span><br><span class="line">        &#125;</span><br><span class="line">            foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues;</span><br><span class="line">    &#125;</span><br><span class="line">    return rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳进createResultObject方法后其实可以看到还有个同名方法，那才是核心所在，我们直接看该方法。对象的构造需要分情况，假如返回值有相应的TypeHandler<br>（往往指基本类型），那么直接条用相应的TypeHandler处理；如果通过构造器映射（@Arg修饰），那么调用有参数的构造函数创建（通过反射，详见ObjectFactory）；<br>其余类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultResultSetHandler</span><br><span class="line"></span><br><span class="line">private Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, </span><br><span class="line">                                  List&lt;Object&gt; constructorArgs, String columnPrefix) &#123;</span><br><span class="line">    if (hasTypeHandlerForResultObject(rsw, resultType)) &#123;</span><br><span class="line">      return createPrimitiveResultObject(rsw, resultMap, columnPrefix);</span><br><span class="line">    &#125; else if (!constructorMappings.isEmpty()) &#123;</span><br><span class="line">      return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix);</span><br><span class="line">    &#125; else if (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123;</span><br><span class="line">      return objectFactory.create(resultType);</span><br><span class="line">    &#125; else if (shouldApplyAutomaticMappings(resultMap, false)) &#123;</span><br><span class="line">      return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，Mybatis的映射过程就分析完成。我们只分析了简单查询的映射过程，留下嵌套查询后续细谈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年春节这几天，全国赶上了严重的冠状病毒疫情，疫情中心武汉封城，许多城市进行交通管制，没有特殊情况尽量不要出门。&lt;br&gt;武汉加油。&lt;/p&gt;
&lt;p&gt;在家无聊，还是更新下博客吧。&lt;/p&gt;
&lt;p&gt;前面说到了，Mybatis在初始化解析注解（xml）阶段，会将结果集到对象的映
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis是如何解析sql语句的</title>
    <link href="http://yoursite.com/2020/01/05/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90sql%E8%AF%AD%E5%8F%A5%E7%9A%84/"/>
    <id>http://yoursite.com/2020/01/05/Mybatis是如何解析sql语句的/</id>
    <published>2020-01-05T12:12:00.000Z</published>
    <updated>2020-01-05T04:12:55.463Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis是如何执行sql的</title>
    <link href="http://yoursite.com/2019/12/31/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8Csql%E7%9A%84/"/>
    <id>http://yoursite.com/2019/12/31/Mybatis是如何执行sql的/</id>
    <published>2019-12-30T23:02:00.000Z</published>
    <updated>2020-01-05T04:09:58.549Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mybatis 3.5.4</p></blockquote><p>到这里，我们已经知道经过各种初始化和解析，Mapper中的sql以及相应的其他信息被封装进了MappedStatement中，<br>而Mapper接口被注册进了MapperRegistry，<br>有了这些”原材料”，就可以开始执行sql了。<br>在说明sql如何执行的时候，我们还需要关注：参数如何被设置到sql中，结果如何与对象映射（这也是mybatis的设计初衷），<br>缓存和事务是如何运行的。</p><p>那么我们开始。</p><p>SqlSessionFactory已经准备就绪，这个时候就需要产生SqlSession，我们仍然抽出主体代码<br>首先可以看到，我们会通过TransactionFactory创建出相应的Transaction，然后由Transaction构造出Executor，<br>这里，Executor就是具体的sql执行器，待会儿会重点讨论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultSqlSessionFactory</span><br><span class="line"></span><br><span class="line">private SqlSession openSessionFromDataSource(ExecutorType execType, </span><br><span class="line">    TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">    final Environment environment = configuration.getEnvironment();</span><br><span class="line">    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    final Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transaction的类型由JdbcTransaction和ManagedTransaction，前者所有事务操作（提交，回滚等）都是借助于jdbc的Connection<br>进行的，而后者则并没有。</p><p>我们跳进configuration.newExecutor这句代码，这里，会根据executorType来决定产生什么样的Executor，比如批处理类型，复用型，缓存型<br>这几种类型的Executor后面会详细讲解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line"></span><br><span class="line">public Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123;</span><br><span class="line">    if (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = new BatchExecutor(this, transaction);</span><br><span class="line">    &#125; else if (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = new ReuseExecutor(this, transaction);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      executor = new SimpleExecutor(this, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    if (cacheEnabled) &#123;</span><br><span class="line">      executor = new CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注最后一句，其实这就是mybatis提供的插件功能，通过实现自己的Interceptor来对executor的接口方法进行增强，<br>我们可以看看interceptorChain.pluginAll究竟做了什么事情，这是个责任链模式，每个Interceptor的plugin方法的返回<br>值都会作为下一个plugin方法的传入参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InterceptorChain</span><br><span class="line"></span><br><span class="line">public Object pluginAll(Object target) &#123;</span><br><span class="line">    for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再跳进interceptor.plugin方法。这是一个接口的默认方法，如果再深入，我们可以知道静态wrap方法返回的是一个jdk的<br>动态代理，被代理的方法是target的接口方法，具体如何代理，取决于Interceptor的intercept方法的实现，而它的参数<br>Invocation正好是target的接口方法的一个调用（是不是有点晕，仔细看看代码就能理解上述的话）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Interceptor</span><br><span class="line"></span><br><span class="line">default Object plugin(Object target) &#123;</span><br><span class="line">    return Plugin.wrap(target, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们回过头来，SqlSession已经创建完成，这个时候，我们开始执行sql。我们知道，mybatis执行sql有两种方式，一种是通过<br>SqlSession的crud方法（传入接口名.方法名），第二种是获取Mapper对象，再通过Mapper对象的方法执行。我们重点讨论第二种<br>（因为这是用的最多的情况）。</p><p>还记得上篇文章的MapperRegistry吗，我们的Mapper是注册到这个对象的，因此，获取Mapper我们也从这个对象获取。<br>MapperProxyFactory在之前初始化阶段就已经加入到knownMappers，因此这里可以通过类型获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapperRegistry</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    return mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们进入到mapperProxyFactory.newInstance，可以看到MapperProxy实现了InvocationHandler，<br>而newInstance方法返回的是JDK动态代理对象，所以这里，我们也知道了，声明的Mapper接口会变成动态代理对象，从而执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapperProxyFactory</span><br><span class="line"></span><br><span class="line">public T newInstance(SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    return newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来看MapperProxy类，可以看到静态代码块里面有些和方法有关的初始化的内容，我们暂且不关心。看其invoke方法<br>可以看到，Mapper的接口方法被转化为了MapperMethod并缓存了起来，调用的时候是调用mapperMethod。那么转化过程是如何的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapperProxy</span><br><span class="line"></span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">    final MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    return mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上MapperMethod由2个部分组成：SqlCommand和MethodSignature，这个两个类的构造参数都是一样的。那么他们有什么不同呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapperMethod</span><br><span class="line"></span><br><span class="line">public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123;</span><br><span class="line">    this.command = new SqlCommand(config, mapperInterface, method);</span><br><span class="line">    this.method = new MethodSignature(config, mapperInterface, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看SqlCommand，可以看出首先会找到对应的MappedStatement，然后设置其name与type（比如@Select，type就是select）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SqlCommand</span><br><span class="line"></span><br><span class="line">public SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">    final String methodName = method.getName();</span><br><span class="line">    final Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,</span><br><span class="line">              configuration);</span><br><span class="line">    name = ms.getId();</span><br><span class="line">    type = ms.getSqlCommandType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看MethodSignature，核心是找到Mapper方法的返回值类型，这里，会判断返回值类型，一共有四种：TypeVariable（类型变量，T），<br>ParameterizedType（参数化类型，比如List<T>），GenericArrayType（数组类型，比如T[]），一般类型（比如String）</T></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MethodSignature</span><br><span class="line"></span><br><span class="line">public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">      Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">      ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的返回类型会经过不同的处理，<br>对于TypeVariable，会首先获取继承的类型，如果有，则取第一个，没有的话就返回Object.class<br>对于ParameterizedType，resolveParameterizedType方法会将尖括号中的参数取出，依次进行处理，最后返回ParameterizedTypeImpl<br>对于GenericArrayType，resolveGenericArrayType会将数组元素类型拿出来，然后进行处理，最后返回GenericArrayTypeImpl<br>其他类型的话直接返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static Type resolveType(Type type, Type srcType, Class&lt;?&gt; declaringClass) &#123;</span><br><span class="line">    if (type instanceof TypeVariable) &#123;</span><br><span class="line">      return resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass);</span><br><span class="line">    &#125; else if (type instanceof ParameterizedType) &#123;</span><br><span class="line">      return resolveParameterizedType((ParameterizedType) type, srcType, declaringClass);</span><br><span class="line">    &#125; else if (type instanceof GenericArrayType) &#123;</span><br><span class="line">      return resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到MethodSignature的构造方法，除了设置返回类型以外，还设置了其他属性，详见注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MethodSignature</span><br><span class="line"></span><br><span class="line">public MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 是否返回void</span><br><span class="line">    this.returnsVoid = void.class.equals(this.returnType);</span><br><span class="line">    // 是否返回值有多个</span><br><span class="line">    this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray();</span><br><span class="line">    // 是否返回游标</span><br><span class="line">    this.returnsCursor = Cursor.class.equals(this.returnType);</span><br><span class="line">    // 是否返回Optional</span><br><span class="line">    this.returnsOptional = Optional.class.equals(this.returnType);</span><br><span class="line">    // @MapKey注解中的返回Map类型的key值</span><br><span class="line">    this.mapKey = getMapKey(method);</span><br><span class="line">    // 是否返回Map</span><br><span class="line">    this.returnsMap = this.mapKey != null;</span><br><span class="line">    // RowBounds类型在方法参数列表的位置</span><br><span class="line">    this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">    // ResultHandler类型在方法参数列表的位置</span><br><span class="line">    this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">    // 参数解析器，构造器中，如果有参数有@Param修饰，那么参数名取注解中的value值，否则直接取声明的参数名字</span><br><span class="line">    // 最后这些参数名会放入到SortedMap中（key是参数位置）</span><br><span class="line">    this.paramNameResolver = new ParamNameResolver(configuration, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MapperMethod就这么被构造完成了，那么就可以执行了，执行的时候调用的是execute方法，可以看到，该方法会根据前面的<br>SqlCommand的类型来决定如何执行，而实际的执行是调用SqlSession的增删改查方法（还记得开头说的两种调用方式吗，本质<br>来说是一种），这里面，比较复杂的是select，这个会最后说。<br>这里增删改查的所有步骤都会包含convertArgsToSqlCommandParam这样一个过程，刚才ParamNameResolver的构造器实际上<br>已经将方法参数转化为一个Map，这里是针对不同情况分别转化（参数为空返回null，只有一个参数，那么直接返回参数值，否则会返回<br>一个ParamMap，key是参数名，value是参数值，不仅如此，这个Map里面还加入了普通参数名，即key为param1，param2…<br>value为参数值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MapperMethod</span><br><span class="line"></span><br><span class="line">public Object execute(SqlSession sqlSession, Object[] args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">        switch (command.getType()) &#123;</span><br><span class="line">            case INSERT: &#123;</span><br><span class="line">                Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">                result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case UPDATE: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            case DELETE: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            case SELECT: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            case FLUSH: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在正式进入到具体的执行方法中，首先看insert，跳进去可以发现，insert其实是调用的update，<br>而一切的一切，最终的执行都是落在Executor上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultSqlSession</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int insert(String statement, Object parameter) &#123;</span><br><span class="line">    return update(statement, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int update(String statement, Object parameter) &#123;</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    return executor.update(ms, wrapCollection(parameter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面有提到过，Executor的构造是通过ExecutorType来选择的，实际上不同的Executor只是在BaseExecutor的基础上<br>继承重写。BaseExecutor是一个模版类，定了update，query等方法，而真正的实现（doUpdate，doQuery）是抽象方法，<br>委托给子类，我们这里讨论SimpleExecutor的实现</p><p>可以看出，执行的时候需要的两个最重要元素：MappedStatement（初始化的时候已经注册，此时直接取出即可），StatementHandler。<br>StatementHandler负责产生出Statement（JDBC规范）以及执行Statement。这个时候我们的sql就被执行完成了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BaseExectutor</span><br><span class="line"></span><br><span class="line">public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    return doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SimpleExecutor</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);</span><br><span class="line">    Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    return handler.update(stmt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述过程还有很多地方没有被挖掘到，我们会在后面的章节继续分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;mybatis 3.5.4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，我们已经知道经过各种初始化和解析，Mapper中的sql以及相应的其他信息被封装进了MappedStatement中，&lt;br&gt;而Mapper接口被注册进了MapperRe
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis是如何生成SqlMapper的</title>
    <link href="http://yoursite.com/2019/12/29/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90sqlMapper%E7%9A%84/"/>
    <id>http://yoursite.com/2019/12/29/Mybatis是如何生成sqlMapper的/</id>
    <published>2019-12-29T14:57:00.000Z</published>
    <updated>2020-03-04T08:05:35.301Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mybatis 3.5.4</p></blockquote><p>着重讨论一下通过注解，interface上面的sql语句是怎么一步一步被解析最终能够执行的。</p><p>首先，mybatis所有声明的sql到mapper的转化都是在初始化阶段完成的。<br>mybatis的执行入口是SqlSession，SqlSession由SqlSessionFactory这个工厂类创建，而SqlSessionFactory<br>是由SqlSessionFactoryBuilder的build方法产生的。</p><p>细看该方法（截取部分）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBuilder</span><br><span class="line"></span><br><span class="line">public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;</span><br><span class="line">    XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">    return build(parser.parse());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际上，第4行的parser.parse()返回的对象是Configuration，这也是mybatis的核心对像。<br>进入到parse()方法，再进到parseConfiguration方法，可以看到他是对xml中的configuration节点进行解析，并且设置数据到对象中<br>此时，我们关心的关键来了 – mapperElement，跳进去</p><p>方法还是比较长的，我们挑重点说：<br>大意是遍历mappers节点的所有子节点，如果子节点是package，那么Configuration中添加包名，否则的话会把resource，url，class等<br>标签拿出来，针对单个mapper做处理，我们先只看第一种情况，如何添加包名从而添加mapper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XMLConfigBuilder</span><br><span class="line"></span><br><span class="line">if (&quot;package&quot;.equals(child.getName())) &#123;</span><br><span class="line">          String mapperPackage = child.getStringAttribute(&quot;name&quot;);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进一步，跳进addMappers方法中，可以看出，所有的mapper类都是被添加到MapperRegistry这样的注册类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Configuration</span><br><span class="line"></span><br><span class="line">public void addMappers(String packageName) &#123;</span><br><span class="line">    mapperRegistry.addMappers(packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跳进去，可以发现核心方法，这里借用了一个ResolverUtil的工具类，目的是为了找到包下面的所有class，这里的superType是Object<br>整个方法作用是找到所有是superType子类的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MapperRegistry</span><br><span class="line"></span><br><span class="line">public void addMappers(String packageName, Class&lt;?&gt; superType) &#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();</span><br><span class="line">    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    for (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">      addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先暂时不管类是怎么找出来的，将目光聚焦在addMapper方法上，主要过程如下，knownMapper，顾名思义是一个缓存，存储的是已知的Mapper，<br>而且不是本身的Mapper类，而是代理的工厂类，我们通过注解方式声明的Mapper会通过该代理工厂最终会转化为代理的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MapperRegistry</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">    MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);</span><br><span class="line">    parser.parse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续，这里又产生了一个parser，它的主要用途是解析Mapper的方法上的注解，进入parse方法，可以看到该方法真正的对各种注解进行解析，<br>parseCache解析的是@CacheNamespace，parseCacheRef解析的是@CacheNamespaceRef，这些是类级别的注解。<br>而parseStatement就是解析方法级别的各种注解<br>可以注意到，方法注解的解析只处理非”桥接”方法。（范型的继承和实现，在类型擦除的过程中，编译器会生成”桥接”方法，该方法实际是一个兼容性<br>的方法，具体可阅读该文章 <a href="https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html）" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MapperAnnotationBuilder</span><br><span class="line"></span><br><span class="line">public void parse() &#123;</span><br><span class="line">    loadXmlResource();</span><br><span class="line">    parseCache();</span><br><span class="line">    parseCacheRef();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">        if (!method.isBridge()) &#123;</span><br><span class="line">            // issue #237</span><br><span class="line">            parseStatement(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是关注代码主干，进入到parseStatement方法<br>parseStatement做的事情还是比较多的，我们一步一步来分析</p><p>首先获取方法的参数类型，如果参数是多个，那么parameterTypeClass的值为ParamMap.class，同时会排除RowBounds和ResultHandler类型<br>然后获取LanguageDriver，通过@Lang注解在Configuration中获得，LanguageDriver的主要用途是翻译sql，常见有xml，raw和velocity<br>（实际上翻译sql的过程也是一个比较复杂而繁琐的，有机会以后会专门开设章节说说sql如何翻译出来的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MapperAnnotationBuilder</span><br><span class="line"></span><br><span class="line">void parseStatement(Method method)</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">    LanguageDriver languageDriver = getLanguageDriver(method);</span><br></pre></td></tr></table></figure><p>接下来的方法，是通过上述信息，把方法注解中的sql语句转化为SqlSource对象，这里有个注意点，sql语句的提供不仅仅是增删改查那几个注解，还有<br>对应的SqlProvider，该方法对这两种情况都做了相应的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MapperAnnotationBuilder</span><br><span class="line"></span><br><span class="line">void parseStatement(Method method)</span><br><span class="line"></span><br><span class="line">    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br></pre></td></tr></table></figure><p>再然后，取出方法注解中的@Options中的各种属性（是否使用缓存，如何刷缓存，结果集类型，表达式（statement）类型，超时时间，是否使用key等等）<br>如果有@SelectKey，那么会将其中sql解析出来，然后放入到configuration的mappedStatement中（这个后面还会说到），并生成SelectKeyGenerator<br>同样注册到Configuration中。<br>之后，如果有@ResultMap，那么解析相关注解</p><p>如果没有ResultMap，并且是一个查询方法，那么会自行解析一个result map，首先会寻找以下注解：@Arg，@Result，@TypeDiscriminator<br>然后分别做解析操作，这里定义result map直接和查询的结果集与对象映射有关，并且会被加入到Configuration中，后面章节会重点讲解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MapperAnnotationBuilder</span><br><span class="line"></span><br><span class="line">private String parseResultMap(Method method) &#123;</span><br><span class="line">    Class&lt;?&gt; returnType = getReturnType(method);</span><br><span class="line">    Arg[] args = method.getAnnotationsByType(Arg.class);</span><br><span class="line">    Result[] results = method.getAnnotationsByType(Result.class);</span><br><span class="line">    TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class);</span><br><span class="line">    String resultMapId = generateResultMapName(method);</span><br><span class="line">    applyResultMap(resultMapId, returnType, args, results, typeDiscriminator);</span><br><span class="line">    return resultMapId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本方法的最后一行（好长….）,MapperBuilderAssistant会将Mapper方法上所有的有关信息汇总起来，封装成MappedStatement对象注册到Configuration<br>中，换言之，Mapper方法上sql在mybatis的最终形态就是MappedStatement</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MapperAnnotationBuilder</span><br><span class="line"></span><br><span class="line">void parseStatement(Method method)</span><br><span class="line"></span><br><span class="line">assistant.addMappedStatement(mappedStatementId, sqlSource, statementType, sqlCommandType, fetchSize,</span><br><span class="line">          timeout,</span><br><span class="line">          // ParameterMapID</span><br><span class="line">          null, parameterTypeClass, resultMapId, getReturnType(method), resultSetType, flushCache,</span><br><span class="line">          useCache,</span><br><span class="line">          // TODO gcode issue #577</span><br><span class="line">          false, keyGenerator, keyProperty, keyColumn,</span><br><span class="line">          // DatabaseID</span><br><span class="line">          null, languageDriver,</span><br><span class="line">          // ResultSets</span><br><span class="line">          options != null ? nullOrEmpty(options.resultSets()) : null);</span><br></pre></td></tr></table></figure><p>至此，回到我们的第一个代码片段，发现SqlSessionFactoryBuilder这个建造类已经将SqlSessionFactory建造出来了，那么这个时候<br>就可以用建造出来的工厂类进一步产生SqlSession以执行相应的语句了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;mybatis 3.5.4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;着重讨论一下通过注解，interface上面的sql语句是怎么一步一步被解析最终能够执行的。&lt;/p&gt;
&lt;p&gt;首先，mybatis所有声明的sql到mapper的转化都是在初始化阶
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"/>
    
    
  </entry>
  
  <entry>
    <title>uuid是如何生成的</title>
    <link href="http://yoursite.com/2019/11/18/uuid%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84/"/>
    <id>http://yoursite.com/2019/11/18/uuid是如何生成的/</id>
    <published>2019-11-18T12:00:00.000Z</published>
    <updated>2019-12-16T14:02:32.426Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mysql" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql对子查询的优化</title>
    <link href="http://yoursite.com/2019/11/18/mysql%E5%AF%B9%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/11/18/mysql对子查询的优化/</id>
    <published>2019-11-17T16:00:00.000Z</published>
    <updated>2020-01-05T04:13:09.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>版本 mysql 8.0+</p></blockquote><p>参照mysql的官方说明手册，对于子查询（subqueries），优化器会采用如下策略：</p><ol><li>针对in, = any, exists<ol><li>semijoin（半连接，针对in）</li><li>Materialization（物化）</li><li>exists 策略</li></ol></li><li>针对not in, &lt;&gt; all, not exists<ol><li>Materialization（物化）</li><li>exists 策略</li></ol></li></ol><p>那么什么是半连接呢？</p><blockquote><p>半连接和join类似，都是基于某些条件将两张表连接起来，但不同的是，半连接仅仅返回一张表的内容<br>半连接最大的好处是减少冗余（想想join返回的是连接两张表之后的内容）</p></blockquote><p>那么什么是物化呢？</p><blockquote><p>将子查询的结果保存为一张带有索引的临时表，后续查询时直接对临时表进行访问</p></blockquote><h3 id="半连接优化in和exists"><a href="#半连接优化in和exists" class="headerlink" title="半连接优化in和exists"></a>半连接优化in和exists</h3><blockquote><p>半连接(semijoin)是一种准备时期的转换，这种转化将采用如下策略：<br>表格剥离，冗余清除，首次匹配，松散扫描和物化</p></blockquote><p>我们观察如下的sql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select class.class_num, class.class_name</span><br><span class="line">from class</span><br><span class="line">inner join roster</span><br><span class="line">where class.class_num = roster.class_num</span><br></pre></td></tr></table></figure><p>其中class_num为主键</p><p>可以看到，这是个join操作，但是仔细观察，我们发现需要返回的结果仅仅是class表的两列，那么这个join<br>操作实际上是冗余的。于是，为了消除冗余，我们可以有如下的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select class_num, class_name</span><br><span class="line">from class</span><br><span class="line">where class_num in </span><br><span class="line">(select class_num from roster)</span><br></pre></td></tr></table></figure><p>这种情况下，返回值仅仅是一张表的某些字段，此时，mysql会使用semijoin<br>在mysql中，还有一种antijoin，这是和semijoin相对的概念，简单来说，就是<br>not in或者not exists<br>要想使用半连接，是有一些前提条件的，比如：<br>select中不能有union关键字<br>不能有having<br>不能包含聚合操作<br>外部查询中不能使用STRAIGHT_JOIN的join类型</p><p>转化为semijoin的时候mysql会采用最开始说的那几种策略，现解释他们的意思：</p><ol><li>将子查询转为join，”表格剥离”指将表从子查询中剥离出来和外部查询进行inner join</li><li>冗余清除指的是类似于join一样运行semijoin，然后用临时表去掉重复记录</li><li>“首次匹配”指只返回第一个符合条件的结果，而不是全部</li><li>“松散扫描”指利用索引在每个子查询中选择值</li><li>“物化”指将子查询转化为基于索引的临时表以进行下一步的join，而索引用作去重</li></ol><h3 id="物化法优化子查询"><a href="#物化法优化子查询" class="headerlink" title="物化法优化子查询"></a>物化法优化子查询</h3><h3 id="exists策略优化子查询"><a href="#exists策略优化子查询" class="headerlink" title="exists策略优化子查询"></a>exists策略优化子查询</h3><p>观察第二个sql，实际上，内部的class_num是外部class_num的条件（即这个class_num必须在<br>roster表中），那么针对这样的子查询，优化器会将其转化为exists语句，也就是exists策略，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select class_num, class_name</span><br><span class="line">from class</span><br><span class="line">where exists</span><br><span class="line">(select * from roster where class.class_num = roster.class_num)</span><br></pre></td></tr></table></figure><p>那么exists的执行过程是如何的呢？<br>由于连接的条件是两个class_num相等，那么在执行sql语句的时候首先会将class表中的class_num依次取出来，<br>然后和内部子查询的roster的class_num做对比，如果相等，那么返回true(子查询返回true)，如果返回true，<br>那么保留class那行的数据。<br>这个时候我们可以想一下，假设class有M条数据，roster有N条数据。<br>再假设class_num上没有索引，那么上述查询就会执行MxN次，效率极低。</p><p>exists策略遵循下面的模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">outer_expr in (select inner_expr from xxx where yyy)</span><br><span class="line">转化为</span><br><span class="line">exists (select 1 from xxx where outer_expr = inner_expr and yyy)</span><br></pre></td></tr></table></figure><p>但是需要注意的是，上述优化能够成立的条件是outer_expr和inner_expr都不为空<br>那么如果其中有null值会发生什么呢？<br>（sql当中null被翻译为”未知的值”）</p><ol><li>outer_expr肯定不返回null但是inner_expr可能返回null<br>那么优化器会将其优化为</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists (select 1 from xxx where outer_expr = inner_expr or inner_expr is null and yyy)</span><br></pre></td></tr></table></figure><ol start="2"><li>outer_expr返回null<br>如果outer_expr是null，那么执行的时候就会是这样</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null in (select inner_expr from xxx where yyy)</span><br></pre></td></tr></table></figure><p>这时就必须要执行一遍里面的select来看inner_expr产生的值<br>上述语句翻译过来就是，当select出任意null值时，结果返回null；当没有select出值时，返回false</p><blockquote><p>为什么null的判断不能放到子查询里面去？因为子查询是对xxx表的判断而不是对外面的表的判断</p></blockquote><p>而如果outer_expr不是null，查询的时候遵照exists优化的策略进行相应转换</p><p>可以看出，null值会使得优化过程变得复杂甚至使得查询变慢。所以在子查询中，要尽量避免内外条件为null的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;版本 mysql 8.0+&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参照mysql的官方说明手册，对于子查询（subqueries），优化器会采用如下策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对in, = any, exists&lt;ol&gt;
&lt;li&gt;sem
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mysql" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/11/09/hello-world/"/>
    <id>http://yoursite.com/2019/11/09/hello-world/</id>
    <published>2019-11-09T02:18:27.202Z</published>
    <updated>2019-11-09T02:18:27.231Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>十一·日本东京（上）</title>
    <link href="http://yoursite.com/2019/11/03/%E5%8D%81%E4%B8%80%C2%B7%E6%97%A5%E6%9C%AC%E4%B8%9C%E4%BA%AC%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2019/11/03/十一·日本东京（上）/</id>
    <published>2019-11-02T21:45:00.000Z</published>
    <updated>2020-01-04T12:14:04.843Z</updated>
    
    <content type="html"><![CDATA[<p>对于我这么宅的人来说，能够花大把的时间出去旅游是一个小概率事件 – <strong>然而概率再小只要不是0也有发生的可能</strong>。<br>去日本的想法是我的同事提出来的，当时我还不知道，那部新海诚的《你的名字》是他动力的来源。<br>刚好从来没有出过国的我也需要感受一下不同的世界，于是，我们一拍即合。<br>为了错开十一的高峰，我们选择提前4天过去（事实证明，这是多么正确的决定）。作为最代表日本的城市，东京也自然而然<br>成为了我们的目的地。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>那么去之前肯定是要做一波提前准备和攻略了。无非就是交通，住宿和钱的问题。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>首先是机票，飞东京的飞机有直飞和中转之分，中转一般来说会花费整个白天<br>的时间，当然价格也更便宜，直飞的话可以在携程或者去哪儿选择打包出售的往返的航班（这里有一个非常坑爹的地方，一般<br>这种打包出售的航班均为廉价航班，比如这次我们定的乐桃航空，那么这种打包的廉价航班的一些缺点就需要格外注意：<br>首先是不支持退票，单程往返都不行，也就是说你不想坐这趟航班了，那么你买票的钱就一去不复返了。然后是无法进行托运，<br>我们当时是每人只能带两个包，并且一个人的总重量最多7KG）。所以航班按需选择才不会吃亏。</p><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>早已耳闻东京的消费是很高的，这一点尤其体现在酒店上面（稍微好点的酒店一晚上就是700+，对于要呆七天的我们来说根本<br>伤不起）。所以民宿就是第一选择。在Airbnb上，根据游玩的地方选住处是不错的策略，住的话也比较推荐住三天及以上（因为<br>这样可以分摊一大笔打扫费和其他费用）。总的来说，一个人大约三百就可以搞定了。我们三人根据路线定了目黑区和港区的民宿，<br><a href="./民宿截图1.jpg">民宿截图1</a><br><a href="./民宿截图2.jpg">民宿截图2</a> </p><h3 id="钱"><a href="#钱" class="headerlink" title="钱"></a>钱</h3><p>即便在东京，也有很多地方不支持信用卡消费（特别是拉面店），所以去之前还是要换购一些日元的，人命币比日元大概是1:15的样子，<br>消费嘛… 一碗拉面大概1000+日元。另外，我不太建议消费的时候都用纸币，能用信用卡还是用信用卡，因为在日本找钱会找给你<br>大量的硬币（硬币有500，200，100这些面额的你敢信），而硬币带回国内是不能换回人民币的。所以换汇按需操作，一天一人300人民币足矣。<br><a href="./带回来的硬币.jpg">带回来的硬币</a></p><h3 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h3><p>其实选择路线是个挺头疼的事情，毕竟第一次去一个完全陌生的城市。所以借鉴了各种大佬的攻略再结合时间安排我们选择了下面的路线图。<br><a href="./路线.png">东京路线</a></p><ul><li>东京湾</li><li>东京塔</li><li>银座</li><li>新宿，歌舞伎町</li><li>皇居</li><li>上野公园，秋叶原</li><li>浅草寺，天空树<br>大概就是这些地方，从下玩到上。后续会详聊。</li></ul><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><p>9月27日，凌晨1点坐上乐桃航空，随着空乘甜美日语的语音播报，东京之行就这么开始了。</p><h3 id="こんにちは、東京（你好，东京）"><a href="#こんにちは、東京（你好，东京）" class="headerlink" title="こんにちは、東京（你好，东京）"></a>こんにちは、東京（你好，东京）</h3><p><a href="./落地东京.jpg">落地东京</a><br>凌晨4点，达到羽田空港，肝了小半个晚上的我们决定先从国际到达前往一号航站楼，然后在那里的胶囊旅馆补充电量。<br><a href="./胶囊旅馆1.jpg">胶囊旅馆1</a><br>小小的胶囊旅馆提供了浴室，到点了会有人过来敲门。<br><a href="./胶囊旅馆2.jpg">胶囊旅馆2</a><br>补充了随眠以及在机场全家吃了点午饭之后，开始赶往民宿。地铁票奇贵，这也是日本交通的一个特点，<br>从机场到民宿的地方大概花了50人民币。（后来的时候买了一种三日通票很有效的缓解了压力）<br><a href="./地铁通票.jpeg">地铁通票</a><br>另外需要吐槽的是，日本的地铁分为不同的公司运营，也就是说一个站内可能会有多家公司的地铁，转乘换乘要找半天。<br>不过，吐槽归吐槽，东京虽然人多地方小，但是极其的有秩序，人们上电梯统一往左靠，给右边留出位置让其他人快速通行。<br>所以乘地铁的时候是人多而不乱的感觉，这一点我真心感觉国内需要学学。<br>透过轨道交通的窗户，第一次看到地表之上的东京。<br>建筑大多都是浅色，白色，或者灰色，非常干净，天空湛蓝，几片厚实的云朵挂在天上，小小的街道，小小的房子，<br>电线杆和电线错落有致，我突然感觉，漫画里的日本就是那个日本，新海诚的画风也恰恰只是还原了他心中的东京而已。<br>目黑区民宿的主人之前有发过一些消息给我，当时没怎么看，下了地铁找民宿的时候打开，竟然是非常非常详细的指南，<br>详细到遇到什么建筑，该往哪里拐，直走一直看到什么再右拐，到达之后什么地方有什么之类的都写的清清楚楚。以图为证。<br><a href="./民宿消息.jpg">民宿消息</a><br>第一家民宿还是非常令人满意的，是一家人别墅中的一个房间，位于安静的小巷中，小巷里有有一个坡，叫做”猫坡”。<br><a href="./民宿图片1.jpg">民宿1</a><br><a href="./民宿图片2.jpg">民宿2</a><br><a href="./民宿图片3.jpg">民宿3</a><br><a href="./民宿图片4.jpg">民宿4</a><br><a href="./猫坡.jpg">猫坡</a></p><h3 id="夜晚东京"><a href="#夜晚东京" class="headerlink" title="夜晚东京"></a>夜晚东京</h3><p>下午三点民宿才开。到了之后自然先补觉，睡地上远远比睡床上舒服～<br>没想到第一次真正近距离的接触东京是在晚上，在中目黑。东京比上海要早一个小时，因此晚上黑的特别快，夜幕下，<br>宽阔的主干道布满了密集而匆匆的行人，上面是偶尔呼啸而过的地铁，周围的小巷里是明亮又精致小巧的店铺。<br>饿了，赶紧找吃的。<br>找店铺就像找男女朋友一样，当前的已经挺好了，却还是希望前面能够有更好的。于是在逛遍几乎整个目黑地铁站附近的商圈<br>后，回头找了一家烧鸟店。一个帅气的日本小哥在吧台的中间现点现烤，即使是英文的菜单，也有很多令人摸不着头脑。于是，<br>本着都试一试的心态再结合粗大的英语技巧，点了烤鸡大腿肉，烤鸡心，烤蔬菜什么的。烤肉是半生的，没有腥味，蘸上芥末<br>口感绵柔。值得一提的是，烤的一朵香菇出奇的好吃，入口有淡淡的奶香。<br><a href="./烧鸟店1.jpg">烧鸟店1</a><br><a href="./烧鸟店2.jpg">烧鸟店2</a><br>在东京，吃的大多要么是传统日式料理（寿司，刺身，拉面），要么是那种结合洋快餐的混搭风（炸鸡，牛排，面包）。<br>酒足饭饱之后自然以闲逛结束疲惫的一天。路上还是非常宁静的，默默行走，但是店内却是另一翻热闹的景象，觥筹交错。在<br>负一楼的地方还有一家叫做”女豹”的店，大概就是穿着暴露的服务小姐陪客人喝酒聊天。<br>anyway，日本之行就这么开始了😃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于我这么宅的人来说，能够花大把的时间出去旅游是一个小概率事件 – &lt;strong&gt;然而概率再小只要不是0也有发生的可能&lt;/strong&gt;。&lt;br&gt;去日本的想法是我的同事提出来的，当时我还不知道，那部新海诚的《你的名字》是他动力的来源。&lt;br&gt;刚好从来没有出过国的我也需要感
      
    
    </summary>
    
    
      <category term="旅行" scheme="http://yoursite.com/categories/%E6%97%85%E8%A1%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>十月·收获与开始</title>
    <link href="http://yoursite.com/2019/10/28/%E5%8D%81%E6%9C%88%C2%B7%E6%94%B6%E8%8E%B7%E4%B8%8E%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2019/10/28/十月·收获与开始/</id>
    <published>2019-10-27T21:45:00.000Z</published>
    <updated>2019-12-07T08:35:57.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="毕业这两年"><a href="#毕业这两年" class="headerlink" title="毕业这两年"></a>毕业这两年</h3><p>2017年本科学位软件工程专业毕业的我带着无数的好奇和憧憬来到上海，加入了一家银行的研发中心。<br>对于一个初出茅庐，刚刚踏入社会的青年来说，一切都是崭新的，一切都是值得探索的，人生的帆船正由自己掌舵，向梦想航行。毕业那年，我都还没满22。<br>但是过来的我们都知道，半年的热情始终会被社会的洪流冷却。这个时候我才明白，一个人在社会中可以如此渺小。走下的地铁，望着穿梭的人群，甚至<br>感觉我好像不属于这里。于是也明白了什么是”哀吾生之须臾，羡长江之无穷”。<br>一个刚毕业不久没啥钱的愣头青什么也做不了。<br>所以，能怎么办？学习，发展，积蓄力量，让自己更加强大。做一个专注的人，做一个纯粹的人，做一个摆脱懒惰的人，做一个抵抗得住诱惑的人。</p><blockquote><p>人嘛，别安于现状。</p></blockquote><p>我知道现阶段的公司肯定不是我的目标，我希望能够更好！<br>于是每天下班回家的事情就是学习，啃书，周末的时间就是刷题，锻炼。<br>弹指一挥间，从本科毕业到现在已经工作了两年的时间。这两年过的不算精彩，但也还充实。<br>没有像同龄人那样能够在该放肆的年纪大胆的去放肆，也没能够有一段轰轰烈烈，精精彩<br>彩的恋爱经历。经常羡慕那些结伴出去玩耍的小伙伴，每到一个适宜旅游的时间段，朋友圈就变成了环球旅行展了，<br>真的让人感慨不已。两年独自战斗还是很寂寞的，没人可以一起讨论，没人可以帮你，为了不那么无聊，这期间还开了个淘宝店，顺便学了下ps（偷笑）。<br>但无论如何，我明白，革命还未成功，同志仍需努力。<br>这两年我把能够读的和开发相关的书都过了一边（我是学Java的，所以这些书你懂的），读了Spring的核心源码，<br>读了Netty的源码，读了N本《深入理解XXX》，刷了250道leetcode。为的是能够在一个合适的时间点更上一层楼！</p><h3 id="迷茫中碰撞"><a href="#迷茫中碰撞" class="headerlink" title="迷茫中碰撞"></a>迷茫中碰撞</h3><p>俗话说”成功是留给有准备的人的”，然而，同样有一句话叫做”成功需要一定的机遇”。</p><blockquote><p>成功需要一定机遇，但前提是你一定要准备。</p></blockquote><p>实际上，在面试其他公司的时候并不是那么一帆风顺。从今年年初开始，我就开始尝试面试各个互联网公司，无一不是以<br>失败告终，大多数都是一面游。确实，互联网行业的技术和金融行业的技术存在不小的鸿沟，我不是在比较技术的优劣，<br>而是想说，要想进入到互联网行业就必须懂得行业的”规矩”，行业需要什么就准备什么。这方面，我还真的是吃过亏。<br>当然了，无论做什么，失败总是总结的最好契机，从每个失败的面试中查漏补缺使我能够快速的知道我缺什么。然后花时间<br>补回来。在我比较满意的面试结果之前，有不下十次的失败面试。也很感慨现在的要求确实越来越高了。而且一次成功的<br>面试还和是否”口径相对”有关。假如说你是开发专长的，去面试的时候岗位是算法方向。那么失败也是必然的。所以也就<br>印证了开头那句话：”成功需要一定的机遇”。</p><h3 id="屡败屡战，终获硕果"><a href="#屡败屡战，终获硕果" class="headerlink" title="屡败屡战，终获硕果"></a>屡败屡战，终获硕果</h3><p>今年的九月，在无数次失败和打击的铺垫下，一路过关斩将，拿到4家公司的offer。每次面试，都是从晚上7点一直聊到<br>10点，从造螺丝，到造轮子，再到造火箭。很多人说：面试造火箭，工作拧螺丝。是的，现实可能就是这样。但别忘了，<br>即便只有百分之十真正在被使用，但剩下那百分之九十就是你行而别人不行的重要体现，也是能够给你更高酬劳的重要体现。</p><blockquote><p>体现你价值的，是那90%</p></blockquote><h3 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h3><p>九月的成功面试让我觉得我这两年的心血没有白费。那颗两年前放在心头的石头也被暂时放下。入职之前顺便去了趟东京了却<br>出国的心愿（开心）。这次也是玩的最开心的一次。也明白了苦尽甘来的意义。这个强者遍地的时代，”小目标”的实现也需要<br>大力气。入职新公司，大家都年轻且聪明，有人只用了三年时间便连升三级，每个人干劲十足，业务和技术框架迭代迅速。<br>挑战很大，机遇很大，”肝”是必须的。人生的波澜壮阔是因为我们主动去迎接一波接一波的挑战，冲破一个又一个大风大浪，<br>逐渐达到胜利的彼岸。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;毕业这两年&quot;&gt;&lt;a href=&quot;#毕业这两年&quot; class=&quot;headerlink&quot; title=&quot;毕业这两年&quot;&gt;&lt;/a&gt;毕业这两年&lt;/h3&gt;&lt;p&gt;2017年本科学位软件工程专业毕业的我带着无数的好奇和憧憬来到上海，加入了一家银行的研发中心。&lt;br&gt;对于一个初出茅
      
    
    </summary>
    
    
      <category term="感悟" scheme="http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
</feed>
