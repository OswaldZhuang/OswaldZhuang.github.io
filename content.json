{"meta":{"title":"Oswald","subtitle":null,"description":null,"author":"Oswald Zhuang","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Spring对bean的加载顺序（2）","slug":"Spring对bean的加载顺序（2）","date":"2020-02-26T20:52:47.000Z","updated":"2020-02-27T15:16:09.425Z","comments":true,"path":"2020/02/27/Spring对bean的加载顺序（2）/","link":"","permalink":"http://yoursite.com/2020/02/27/Spring%E5%AF%B9bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%882%EF%BC%89/","excerpt":"","text":"之前我们说到包扫描时候类资源是如何被spring读取进来并包装为Resource返回然后再由MetadataReader读取其中注解信息（暂时略过）最终生成BeanDefinition的而实际上BeanDefinition转化为实际的bean之前还需要被注册进BeanFactory中，接下来我们讨论一下注册的过程 还记得上一篇文章的第二个代码片段吗，我只列出了前半段获取BeanDefinition的过程，现列出后半段篇幅很长但有用的信息很多1处：处理@Scope注解2处：生成bean的名字3处：设置bean为autowire模式4处：处理@Lazy，@Primary，@DependsOn，@Role，@Description这样的公共注解5处：设置代理模式（如果有的话）6处：向BeanFactory注册BeanDefinition 12345678910111213141516171819202122232425262728ClassPathBeanDefinitionScannerprotected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; ... for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); // 1 candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); // 2 if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); // 3 &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); // 4 &#125; if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); // 5 beanDefinitions.add(definitionHolder); registerBeanDefinition(definitionHolder, this.registry); //6 &#125; &#125;&#125; 一步步进入到上述6处的代码中，该方法做两件事情：向BeanFactory注册BeanDefinition（1）和别名Alias（2） 123456789BeanDefinitionReaderUtilspublic static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 1 ... // 2&#125; 再进一步深入上述1处的代码，省略的注释1处的代码是”已经存在同名的BeanDefinition”以及”创建bean的过程已经开始的时候”的情况的处理我们可以先不看剩下的就是BeanDefinition第一次被注册进来的逻辑：很简单，不是吗，维护两个主要的数据结构：Map类型的bean名字和定义的映射；顺序存储bean名字的List 1234567891011DefaultListableBeanFactorypublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; ... // 1 this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName);&#125; 再回想一下，ClassPathBeanDefinitionScanner在扫描给定路径下类文件后转化为Resource是按照文件名的字典序排序的，然后遍历的将其注册到BeanFactory中，所以List结构的bean名字顺序即给定路径下的文件字典序而ApplicationContext在真正创建bean的时候又是遍历存有bean名字的链表（可见另一篇文章 &lt;Spring bean的获取过程&gt;）因此spring加载给定路径下bean的大致顺序为文件名的字典序","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"spring","slug":"技术/spring","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/spring/"}],"tags":[]},{"title":"Spring对bean的加载顺序（1）","slug":"Spring对bean的加载顺序（1）","date":"2020-02-23T15:58:21.000Z","updated":"2020-02-26T12:51:46.011Z","comments":true,"path":"2020/02/23/Spring对bean的加载顺序（1）/","link":"","permalink":"http://yoursite.com/2020/02/23/Spring%E5%AF%B9bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%881%EF%BC%89/","excerpt":"","text":"spring的容器会通过以下方式获取bean： 1.xml 2.Java的Configuration（@Bean） 3.@ComponentScan的包下面的各个类（@Component修饰） *看到这里可能会疑惑为什么没有@Service，@Repository，@Controller等等， 实际上，如果仔细去看这些注解的话，可以知道这些注解均被@Component修饰， 事实就是spring只认@Component读取这些bean的类信息，将其封装为BeanDefinition，并通过某种方式排序，为后面的refresh阶段作准备。 现在，我们就来研究这一过程。 如果我们去看ApplicationContext的类实现结构，我们可以发现，每一种不同的实现其实是基于bean的来源，比如ClassPathXmlApplicationContext的bean来源就是class path下的xml文件AnnotationConfigApplicationContext的bean来源就是注解修饰的类等等 由于现在很多时候我们都不用xml这种古老的方式了，故我们分析下第二种：注解方式 首先看下它的众多构造函数之一： 可以看到构造函数中不仅传入了BeanFactory，还新增了两个成员，从名字就可以知道他们的作用：reader – 读取java Configuration类中定义的@Bean修饰成员scanner – 扫描class path下面的@Component修饰的类并转化为BeanDefinition 123456public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) &#123; super(beanFactory); this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this);&#125; 直接进到doScan方法中，可以看到，其传入包路径，返回BeanDefinitionHolder，这正是我们需要关注研究的内容1处的代码着重会读取class文件内容以及生成相应的bean定义2处的代码会设置相关的scope信息及一些后续处理 123456789ClassPathBeanDefinitionScannerprotected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; for (String basePackage : basePackages) &#123; Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); // 1 ... // 2 &#125; &#125;&#125; 一步步跳进上面1处的代码中，可得如下代码片段第一步会根据传来的包名来获取该路径下所有的Resource，为路径下的class文件，jar包内的class文件等等，其中packageSearchPath的值为classpath:/&lt;传入的路径&gt;/**/.class，即整个类路径下的所有目录下的class文件第二步，将这些resource的MateData（各种spring注解的内容）解析出来本文暂时不会关心元数据的解析过程，我们还是看resource是如何读进来的 12345678910111213141516ClassPathScanningCandidateComponentProviderprivate Set&lt;BeanDefinition&gt; scanCandidateComponents(String basePackage) &#123; Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath); // 1 for (Resource resource : resources) &#123; MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); // 2 if (isCandidateComponent(metadataReader)) &#123; ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); &#125; &#125; ...&#125; 跳进上面1中代码1处代码负责解析出根目录的resource（这里其实包含的是路径，即返回URLResource，而该过程采用ClassLoader完成），比如传入的package是com.example.a，那么rootDirResource的路径就是&lt;绝对类路径&gt;/com/example/a/2处代码返回本身，供扩展使用接下来，会判断URL类型，比如VFS，jar，否则采用3处的方式 12345678910111213PathMatchingResourcePatternResolverprotected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; String rootDirPath = determineRootDir(locationPattern); Resource[] rootDirResources = getResources(rootDirPath); // 1 for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); // 2 ... result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); // 3 ... &#125;&#125; 进入上面3的代码，可以很清楚的看到，是通过File的方式查找根目录下的”资源” 1234567PathMatchingResourcePatternResolverprotected Set&lt;Resource&gt; doFindPathMatchingFileResources(Resource rootDirResource, String subPattern) throws IOException &#123; File rootDir = rootDirResource.getFile().getAbsoluteFile(); return doFindMatchingFileSystemResources(rootDir, subPattern); // 2&#125; 一步步进入到2中代码里去可以看到，该方法首先将当前目录下的文件列出来（1处），随后对他们进行排序（2处），而排序的规则是”字典序”随后，遍历这些文件，对目录类型的文件递归的调用此方法（3处），对于普通文件，加入到结果中（4处）比如你传入的路径为com.example，该路径下有目录A，文件D，而A下面有B，C两个文件那么最终result的结果便是A，B，C，D这些File会被包装为FileSystemResource最终返回 123456789101112131415PathMatchingResourcePatternResolverprotected void doRetrieveMatchingFiles(String fullPattern, File dir, Set&lt;File&gt; result) throws IOException &#123; File[] dirContents = dir.listFiles(); // 1 Arrays.sort(dirContents); // 2 for (File content : dirContents) &#123; if (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + &quot;/&quot;)) &#123; doRetrieveMatchingFiles(fullPattern, content, result); // 3 &#125; if (getPathMatcher().match(fullPattern, currPath)) &#123; result.add(content); // 4 &#125; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"spring","slug":"技术/spring","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/spring/"}],"tags":[]},{"title":"Spring bean的获取过程","slug":"Spring bean的获取过程","date":"2020-02-01T11:16:37.000Z","updated":"2020-02-23T11:50:24.261Z","comments":true,"path":"2020/02/01/Spring bean的获取过程/","link":"","permalink":"http://yoursite.com/2020/02/01/Spring%20bean%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Spring获取bean实例是通过BeanFactory#getBean方法 getBean不仅仅是从容器中取出已有的bean，如果容器中还不存在该bean，getBean还会将其实例化再返回。事实上，spring容器启动的时候bean的实例化正是通过getBean完成的。 现分析容器初始化时bean的实例化过程 省略掉refresh时前后阶段的各种准备与事件发布过程，非懒加载的bean的初始化（包括实例化，代理等）入口即下面这句 1234567AbstractApplicationContextpublic void refresh() throws BeansException, IllegalStateException &#123; ... finishBeanFactoryInitialization(beanFactory); ...&#125; 跳进去，前面的代码用于初始化特定类型的bean，比如ConversionService，LoadTimeWeaverAware，我们不必关系，只看最后一句 123456AbstractApplicationContextprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; ... beanFactory.preInstantiateSingletons();&#125; 继续看这个方法，可以看到，实例化bean的时候是遍历bean的名字，然后依次实例化，对于FactoryBean来说，其名字由bean名与特殊前缀构成，而这个前缀是’&amp;’符号，随后，统一采用getBean来实例化每个bean，geBean简单的调用doGetBean方法 123456789101112131415DefaultListableBeanFactory@Overridepublic void preInstantiateSingletons() throws BeansException &#123; ... for (String beanName : beanNames) &#123; if (isFactoryBean(beanName)) &#123; Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); &#125; else &#123; getBean(beanName); &#125; &#125; ...&#125; doGetBean方法比较长也比较复杂，这里提取了一些关键的步骤依次分析，首先通过getSingleton获取缓存中是否已经存在，具体来说，已经创建出来的bean会存在singletonObjects，earlySingletonObjects，singletonFactories（用于FactoryBean）（以上皆为BeanFactory成员变量）中。如果存在的话直接返回。如果不存在的话，首先校验当前线程是否正在创建该bean且是prototype类型，如果是，那么可以认为是产生循环依赖，抛出异常（为什么这么做？）然后遍历其dependsOn，即@DependsOn，并依次实例化这些”依赖”，并监测期间是否存在循环依赖（具体可见步骤3里for里面的代码）（和一般bean的循环依赖略有不同，@DependsOn不允许出现A依赖B，B依赖A的情况，一般bean的循环依赖后面会讲）最后就是bean的实例化了，实际上真正创建bean的就是传入的lambda中那个createBean方法。 123456789101112131415161718192021222324252627AbstractBeanFactoryprotected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123; Object sharedInstance = getSingleton(beanName); // 1 if (sharedInstance != null &amp;&amp; args == null) &#123; ... &#125; else &#123; if (isPrototypeCurrentlyInCreation(beanName)) &#123; // 2 throw new BeanCurrentlyInCreationException(beanName); &#125; for (String dep : dependsOn) &#123;...&#125; // 3 sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); // 4 &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125;); &#125; ... return bean;&#125; 先从createBean开始 剔除不那么关注的代码，其实创建bean的主要过程就两个，1处的代码通过调用各种BeanPostProcessor创建bean，具体来说，实例化是由InstantiationAwareBeanPostProcessor完成（AOP中还会有他的身影），实例化后再由其他BeanPostProcessor后置处理假如说就是很普通的我们声明的bean，那么就走2处代码。 1234567891011121314AbstractAutowireCapableBeanFactory@Override protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; ... Object bean = resolveBeforeInstantiation(beanName, mbdToUse); // 1 if (bean != null) &#123; return bean; &#125; Object beanInstance = doCreateBean(beanName, mbdToUse, args); // 2 return beanInstance; ...&#125; doCreateBean的主要步骤如下，实际上，bean创建的时候返回的是BeanWrapper的包装对象，步骤一bean对象完成了真正的实例化，包括通过构造函数（有参数，无参数），工厂方法，该步骤后续会详讲。步骤二将创建出的bean缓存在singletonObjects，回忆一下对doGetBean方法的解读，虽然bean还没有完全创建结束（比如属性的autowire还没开始），但是先将其缓存起来，防止了循环依赖的问题（没有缓存判断，循环依赖下创建bean将是死循环）步骤三，进行bean属性的自动绑定（autowire）和其他一些动作步骤四，实现各种Aware接口以及InitializingBean 12345678910111213141516AbstractAutowireCapableBeanFactoryprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = createBeanInstance(beanName, mbd, args); // 1 final Object bean = instanceWrapper.getWrappedInstance(); addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); // 2 Object exposedObject = bean; populateBean(beanName, mbd, instanceWrapper); // 3 exposedObject = initializeBean(beanName, exposedObject, mbd); // 4 return exposedObject;&#125; 跳到createBeanInstance方法，无论条件如何，创建BeanWrapper的方式有以下几种 通过Supplier 通过工厂方法（比如Spring Configuration申明的bean） 带参数的构造函数自动绑定 构造函数默认参数直接创建这几种构造方式后面将会详细分析12345678910111213AbstractAutowireCapableBeanFactoryprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123; ... return obtainFromSupplier(instanceSupplier, beanName); // 1 ... return instantiateUsingFactoryMethod(beanName, mbd, args); // 2 ... return autowireConstructor(beanName, mbd, null, null); // 3 ... return instantiateBean(beanName, mbd); // 4 ...&#125; 回到前面的populateBean方法，前面会通过InstantiationAwareBeanPostProcessor（如果有的话）做一些处理，然后根据BeanDefinition中设置的自动绑定模式来决定如何进行自动绑定，也就是1和2的代码选其一执行之，那么执行这两步（其中之一）之后就真的把依赖注入到了bean中呢？答案是否定的，执行完1/2步骤的结果会被设置到PropertyValues对象中，再经由步骤3设置进去 12345678910AbstractAutowireCapableBeanFactoryprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; ... autowireByName(beanName, mbd, bw, newPvs); // 1 ... autowireByType(beanName, mbd, bw, newPvs); // 2 ... applyPropertyValues(beanName, mbd, bw, pvs); // 3&#125; 我们以autowireByName为例，实现是比较简单的，遍历属性名，然后递归调用getBean获取bean，再将其添加到PropertyValues，最后将依赖关系注册到dependenciesForBeanMap（Map&lt;String, Set&gt;类型，key是bean名字，value是依赖集合） 12345678910AbstractAutowireCapableBeanFactoryprotected void autowireByName( String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) &#123; for (String propertyName : propertyNames) &#123; Object bean = getBean(propertyName); pvs.add(propertyName, bean); registerDependentBean(propertyName, beanName); &#125;&#125; autowireByType方法比较复杂，限于篇幅，这里只给结果，日后有时间再议： 再看applyPropertyValues，前面是一些关于PropertyValue的转化操作，而真正设置bean属性的是其setPropertyValues方法，这个方法非常长，简单的说，是通过反射调用writeMethod写入属性后面章节会详细说明其过程 1234567AbstractAutowireCapableBeanFactoryprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) &#123; ... bw.setPropertyValues(new MutablePropertyValues(deepCopy)); ...&#125; 如是，获得bean完成。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"spring","slug":"技术/spring","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/spring/"}],"tags":[]},{"title":"Mybatis的缓存机制","slug":"Mybatis的缓存机制","date":"2020-02-01T11:16:37.000Z","updated":"2020-02-23T11:49:24.076Z","comments":true,"path":"2020/02/01/Mybatis的缓存机制/","link":"","permalink":"http://yoursite.com/2020/02/01/Mybatis%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Mybatis的缓存有两种：一级缓存，二级缓存。 一级缓存的作用域为SqlSession，二级缓存的作用域为某条Sql（或者准确的说是MappedStatement） 那么他们的区别和工作流程是怎么样的呢？ ###一级缓存从前面的分析中我们知道，在进行查询的时候，Mybatis会调用SqlSession进而调用Executor来执行sql语句。而一切Executor的基础类是BaseExecutor（这也是个模板类），在BaseExecutor中有这么一段代码其中localCache就是所谓的一级缓存，先从缓存中拿数据，拿不到再查库，这是典型的写法，注意到这里缓存的key是CacheKey，这个key是如何被计算出来的，后面会详解其中handleLocallyCachedOutputParameters的处理事针对存储过程，在此不做讨论。 123456789101112BaseExecutorpublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) &#123; handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; &#125; 而查库的时候，也是按照标准的写法，首先在缓存中写入一个占位符（为啥要这样？），然后查库，最后清除占位符再把实际数据写进去 12345678910111213BaseExecutorprivate &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; localCache.putObject(key, EXECUTION_PLACEHOLDER); try &#123; list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); &#125; finally &#123; localCache.removeObject(key); &#125; localCache.putObject(key, list);&#125; 接下来，看看一级缓存的具体实现，其实例化是在Executor的构造函数中，Perpetual是永久的意思，表明它是一直存在的 12345protected BaseExecutor(Configuration configuration, Transaction transaction) &#123; ... this.localCache = new PerpetualCache(&quot;LocalCache&quot;); ...&#125; 再看看其实现，非常简单，就是一个HashMap，所以倒过来，我们可以想想，Executor非线程安全（因为Cache），SqlSession也非线程安全（因为Executor） 123public class PerpetualCache implements Cache &#123; private final Map&lt;Object, Object&gt; cache = new HashMap&lt;&gt;();&#125; 还有个问题，既然运用了缓存，那么必然存在脏读脏写的问题，如果另一个线程更新了数据会如何呢？实际上，在更新操作发生之前，就会对缓存进行清除，而Mybatis的做法是：全部清除clearLocalCache调用的就是PerpetualCache中HashMap的clear方法 123456BaseExecutorpublic int update(MappedStatement ms, Object parameter) throws SQLException &#123; clearLocalCache(); return doUpdate(ms, parameter);&#125; 回到第一个问题，CacheKey是如何被计算出来的，在真正的query之前，会通过createCacheKey计算出CacheKey对象，简单的看看这个方法，key值和MappedStatement的Id（类名.方法名），RowBounds，sql语句，value，Environment的Id有关，而value的值和传入参数相关 12345678910111213BaseExecutorpublic CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; CacheKey cacheKey = new CacheKey(); cacheKey.update(ms.getId()); cacheKey.update(rowBounds.getOffset()); cacheKey.update(rowBounds.getLimit()); cacheKey.update(boundSql.getSql()); cacheKey.update(value); cacheKey.update(configuration.getEnvironment().getId()); return cacheKey;&#125; 再看key的update方法，该方法的目标就是计算出key的hash值（想想HashMap的put方法实现），具体是将（传入参数的hash值乘以当前已经update的对象的个数）然后加上（CacheKey的hash值乘以multiplier（默认37）的值）这么做我想是为了尽量减少哈希的冲突 12345678910111213CacheKeypublic void update(Object object) &#123; int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); count++; checksum += baseHashCode; baseHashCode *= count; hashcode = multiplier * hashcode + baseHashCode; updateList.add(object);&#125; ###二级缓存 之前有提到，BaseExecutor中有个子类是CachingExecutor，这就是运用二级缓存应用的地方，我们首先找到其query方法，把运用缓存那一段抽出来可以看出，这个Cache并不是Executor的成员，而是MappedStatement的。然而，对象的提取并不是直接从这个cache拿出来的，而是通过TransactionalCacheManager（代码中的tcm）。 12345678910111213CachingExecutorpublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; Cache cache = ms.getCache(); flushCacheIfRequired(ms); List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); if (list == null) &#123; list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); &#125; return list;&#125; 观察TransactionalCacheManager的结构，其维护了Cache和TransactionalCache对，真正的操作发生在TransactionalCache上这里或许有个疑问，那就是为什么设置两个cache？其实这里是一个巧妙的做法，作为key的Cache是缓存的具体实现，而作为value的TransactionalCache是对key的封装，并提供一个统一的与事务相关的功能。观察getTransactionalCache方法的实现，传入的cache实际是TransactionalCache的构造函数的参数 1234567891011public class TransactionalCacheManager &#123; private final Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;&gt;(); public Object getObject(Cache cache, CacheKey key) &#123; return getTransactionalCache(cache).getObject(key); &#125; private TransactionalCache getTransactionalCache(Cache cache) &#123; return transactionalCaches.computeIfAbsent(cache, TransactionalCache::new); &#125;&#125; 继续看TransactionalCache的实现，该类维护了很多成员变量，这里的delegate即上述真正的实现类，entriesToAddOnCommit是事务提交时才会添加缓存的对象，entriesMissedInCache是未命中缓存的key集合。可以看到，putObject并没有把待缓存对象直接放入delegate中，而是放入了entriesToAddOnCommit，同时getObject在delegate中未找到时会把key添加到entriesMissedInCache。那么问题来了，待缓存对象什么时候能添加到真正的delegate中呢？答案是调用其commit方法时。commit方法（这里只截取了部分代码）调用了flushPendingEntries，该方法会遍历entriesToAddOnCommit，然后再通过delegate添加缓存 12345678910111213141516171819202122232425262728public class TransactionalCache implements Cache &#123; public TransactionalCache(Cache delegate) &#123; this.delegate = delegate; this.clearOnCommit = false; this.entriesToAddOnCommit = new HashMap&lt;&gt;(); this.entriesMissedInCache = new HashSet&lt;&gt;(); &#125; @Override public void putObject(Object key, Object object) &#123; entriesToAddOnCommit.put(key, object); &#125; @Override public Object getObject(Object key) &#123; Object object = delegate.getObject(key); if (object == null) &#123; entriesMissedInCache.add(key); &#125; return object; &#125; public void commit() &#123; flushPendingEntries(); &#125;&#125; 那么，TransactionalCache的commit又是什么时候调用的呢？答案是通过TransactionalCacheManager的commit，而该commit是由Executor的commit调用，而Executor的commit最终由SqlSession调用。可以看出，二级缓存是通过事务提交而生效的。 尽管Mybatis中的Cache的实现看起来多种多样，但这些所谓的”实现”都只是装饰类，仅仅是用名称表明功能而已。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mybatis","slug":"技术/mybatis","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"}],"tags":[]},{"title":"Mybatis是如何解析结果集的","slug":"Mybatis是如何解析结果集的","date":"2020-01-27T16:43:25.000Z","updated":"2020-05-23T08:44:11.452Z","comments":true,"path":"2020/01/28/Mybatis是如何解析结果集的/","link":"","permalink":"http://yoursite.com/2020/01/28/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9A%84/","excerpt":"","text":"2020年春节这几天，全国赶上了严重的冠状病毒疫情，疫情中心武汉封城，许多城市进行交通管制，没有特殊情况尽量不要出门。武汉加油。 在家无聊，还是更新下博客吧。 前面说到了，Mybatis在初始化解析注解（xml）阶段，会将结果集到对象的映射解析成为ResultMap并注册到Configuration中。在执行完sql语句（Statement）时，StatementHandler会负责将结果集映射到我们需要的对象。 12345678PreparedStatementHandler@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; ps.execute(); return resultSetHandler.handleResultSets(ps);&#125; 跳进最后一行，是DefaultResultSetHandler的handleResultSets方法，这是个比较长的方法，大部分代码是关于多个ResultMap的处理，至于这些ResultMap是如何生成以及如何使用，后面章节会细讲。如果仔细观察的话，会发现真正用在处理结果集的只有一行。而return那一行是将解析出来的对象展开为list形式。假如说我们什么结果也没有查询出来，那么该方法返回的是什么呢？整体的看下这个方法，可以知道是空的ArrayList。但是需要注意的是：如果mapper的返回值是单个对象，那么db中没有数据的时候，返回值是null。 123456DefaultResultSetHandlerpublic List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123; handleResultSet(rsw, resultMap, multipleResults, null); return collapseSingleResultList(multipleResults);&#125; 跳进上面那个handleResultSet方法，仍然只关注重点，我们或许会感到奇怪，这个方法是void方法，最终生成的对象跑到哪里去了呢？实际上，有两个途径，一个是传入参数multipleResults，另一个是ResultHandler，ResultHandler是DefaultResultSetHandler的一个成员，而ResultHandler中正是保存了最终生成的结果（List或者Map，对应Mybatis中的两个默认实现DefaultResultHandler，DefaultMapResultHandler）。最终，映射结果集每行数据的任务就落到了handleRowValues方法上。 123456DefaultResultSetHandlerprivate void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123; handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);&#125; 走进handleResultSet方法，上面的是嵌套查询的映射，下面是简单映射，即一列数据对应一条属性。 12345678910DefaultResultSetHandlerpublic void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; if (resultMap.hasNestedResultMaps()) &#123; handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping); &#125; else &#123; handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping); &#125;&#125; 还是来看看简单映射，大致分为三步，首先获取Discriminator中的ResultMap，假如说没有Discriminator，那么返回之前的ResultMap（也就是传入参数）。然后得到真正我们需要的对象。最后，将得到的对象存到ResultContext和ResultHandler中。那么第二步肯定是我们关注的重点。 12345678910DefaultResultSetHandlerprivate void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping) &#123; while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123; ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null); Object rowValue = getRowValue(rsw, discriminatedResultMap, null); storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet); &#125;&#125; 将代码缩减一下，可以得到下面几个比较关键的步骤，其中createResultObject会将所需对象以各种形式创建出来，这一点后面会详细说明，随后，假如该对象没有对应的TypeHandler，那么新建一个MetaObject，注意到，MetaObject是所需对象的一个包装对象，目的是提供统一的接口以设置映射对象的属性（比如说通过无参数构造器创建了User对象，那么其中的name，age等属性则通过MetaObject设置）下面，如果设置自动映射的话则采取自动映射（默认情况下该未true），最后采取属性映射。值得说明的是，applyAutomaticMapping是用于没有显示指明映射关系的列，他与applyPropertyMappings的作用是一致的，即通过注册的TypeHandler进行转换，然后通过MetaObject的setValue方法为目标对象设置属性值。我们的重点还是放到第一行，对象的构造。 1234567891011121314DefaultResultSetHandlerprivate Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix) throws SQLException &#123; Object rowValue = createResultObject(rsw, resultMap, lazyLoader, columnPrefix); final MetaObject metaObject = configuration.newMetaObject(rowValue); boolean foundValues = this.useConstructorMappings; if (rowValue != null &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123; if (shouldApplyAutomaticMappings(resultMap, false)) &#123; foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix) || foundValues; &#125; foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix) || foundValues; &#125; return rowValue;&#125; 跳进createResultObject方法后其实可以看到还有个同名方法，那才是核心所在，我们直接看该方法。对象的构造需要分情况，假如返回值有相应的TypeHandler（往往指基本类型），那么直接条用相应的TypeHandler处理；如果通过构造器映射（@Arg修饰），那么调用有参数的构造函数创建（通过反射，详见ObjectFactory）；其余类似 1234567891011121314DefaultResultSetHandlerprivate Object createResultObject(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs, String columnPrefix) &#123; if (hasTypeHandlerForResultObject(rsw, resultType)) &#123; return createPrimitiveResultObject(rsw, resultMap, columnPrefix); &#125; else if (!constructorMappings.isEmpty()) &#123; return createParameterizedResultObject(rsw, resultType, constructorMappings, constructorArgTypes, constructorArgs, columnPrefix); &#125; else if (resultType.isInterface() || metaType.hasDefaultConstructor()) &#123; return objectFactory.create(resultType); &#125; else if (shouldApplyAutomaticMappings(resultMap, false)) &#123; return createByConstructorSignature(rsw, resultType, constructorArgTypes, constructorArgs); &#125;&#125; 到此，Mybatis的映射过程就分析完成。我们只分析了简单查询的映射过程，留下嵌套查询后续细谈。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mybatis","slug":"技术/mybatis","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"}],"tags":[]},{"title":"Mybatis是如何解析sql语句的","slug":"Mybatis是如何解析sql语句的","date":"2020-01-05T12:12:00.000Z","updated":"2020-01-05T04:12:55.463Z","comments":true,"path":"2020/01/05/Mybatis是如何解析sql语句的/","link":"","permalink":"http://yoursite.com/2020/01/05/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90sql%E8%AF%AD%E5%8F%A5%E7%9A%84/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mybatis","slug":"技术/mybatis","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"}],"tags":[]},{"title":"Mybatis是如何执行sql的","slug":"Mybatis是如何执行sql的","date":"2019-12-30T23:02:00.000Z","updated":"2020-01-05T04:09:58.549Z","comments":true,"path":"2019/12/31/Mybatis是如何执行sql的/","link":"","permalink":"http://yoursite.com/2019/12/31/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8Csql%E7%9A%84/","excerpt":"","text":"mybatis 3.5.4 到这里，我们已经知道经过各种初始化和解析，Mapper中的sql以及相应的其他信息被封装进了MappedStatement中，而Mapper接口被注册进了MapperRegistry，有了这些”原材料”，就可以开始执行sql了。在说明sql如何执行的时候，我们还需要关注：参数如何被设置到sql中，结果如何与对象映射（这也是mybatis的设计初衷），缓存和事务是如何运行的。 那么我们开始。 SqlSessionFactory已经准备就绪，这个时候就需要产生SqlSession，我们仍然抽出主体代码首先可以看到，我们会通过TransactionFactory创建出相应的Transaction，然后由Transaction构造出Executor，这里，Executor就是具体的sql执行器，待会儿会重点讨论。 12345678910DefaultSqlSessionFactoryprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit);&#125; Transaction的类型由JdbcTransaction和ManagedTransaction，前者所有事务操作（提交，回滚等）都是借助于jdbc的Connection进行的，而后者则并没有。 我们跳进configuration.newExecutor这句代码，这里，会根据executorType来决定产生什么样的Executor，比如批处理类型，复用型，缓存型这几种类型的Executor后面会详细讲解。 123456789101112131415Configurationpublic Executor newExecutor(Transaction transaction, ExecutorType executorType) &#123; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; if (cacheEnabled) &#123; executor = new CachingExecutor(executor); &#125; executor = (Executor) interceptorChain.pluginAll(executor);&#125; 重点关注最后一句，其实这就是mybatis提供的插件功能，通过实现自己的Interceptor来对executor的接口方法进行增强，我们可以看看interceptorChain.pluginAll究竟做了什么事情，这是个责任链模式，每个Interceptor的plugin方法的返回值都会作为下一个plugin方法的传入参数。 12345678InterceptorChainpublic Object pluginAll(Object target) &#123; for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target;&#125; 再跳进interceptor.plugin方法。这是一个接口的默认方法，如果再深入，我们可以知道静态wrap方法返回的是一个jdk的动态代理，被代理的方法是target的接口方法，具体如何代理，取决于Interceptor的intercept方法的实现，而它的参数Invocation正好是target的接口方法的一个调用（是不是有点晕，仔细看看代码就能理解上述的话） 12345Interceptordefault Object plugin(Object target) &#123; return Plugin.wrap(target, this);&#125; 我们回过头来，SqlSession已经创建完成，这个时候，我们开始执行sql。我们知道，mybatis执行sql有两种方式，一种是通过SqlSession的crud方法（传入接口名.方法名），第二种是获取Mapper对象，再通过Mapper对象的方法执行。我们重点讨论第二种（因为这是用的最多的情况）。 还记得上篇文章的MapperRegistry吗，我们的Mapper是注册到这个对象的，因此，获取Mapper我们也从这个对象获取。MapperProxyFactory在之前初始化阶段就已经加入到knownMappers，因此这里可以通过类型获取。 123456MapperRegistrypublic &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); return mapperProxyFactory.newInstance(sqlSession);&#125; 我们进入到mapperProxyFactory.newInstance，可以看到MapperProxy实现了InvocationHandler，而newInstance方法返回的是JDK动态代理对象，所以这里，我们也知道了，声明的Mapper接口会变成动态代理对象，从而执行。 123456MapperProxyFactorypublic T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy);&#125; 重点来看MapperProxy类，可以看到静态代码块里面有些和方法有关的初始化的内容，我们暂且不关心。看其invoke方法可以看到，Mapper的接口方法被转化为了MapperMethod并缓存了起来，调用的时候是调用mapperMethod。那么转化过程是如何的呢？ 123456MapperProxypublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args);&#125; 实际上MapperMethod由2个部分组成：SqlCommand和MethodSignature，这个两个类的构造参数都是一样的。那么他们有什么不同呢？ 123456MapperMethodpublic MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123; this.command = new SqlCommand(config, mapperInterface, method); this.method = new MethodSignature(config, mapperInterface, method);&#125; 首先看SqlCommand，可以看出首先会找到对应的MappedStatement，然后设置其name与type（比如@Select，type就是select） 12345678910SqlCommandpublic SqlCommand(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123; final String methodName = method.getName(); final Class&lt;?&gt; declaringClass = method.getDeclaringClass(); MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration); name = ms.getId(); type = ms.getSqlCommandType();&#125; 继续看MethodSignature，核心是找到Mapper方法的返回值类型，这里，会判断返回值类型，一共有四种：TypeVariable（类型变量，T），ParameterizedType（参数化类型，比如List），GenericArrayType（数组类型，比如T[]），一般类型（比如String） 123456MethodSignaturepublic MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123; Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface); ... &#125; 不同的返回类型会经过不同的处理，对于TypeVariable，会首先获取继承的类型，如果有，则取第一个，没有的话就返回Object.class对于ParameterizedType，resolveParameterizedType方法会将尖括号中的参数取出，依次进行处理，最后返回ParameterizedTypeImpl对于GenericArrayType，resolveGenericArrayType会将数组元素类型拿出来，然后进行处理，最后返回GenericArrayTypeImpl其他类型的话直接返回 1234567891011private static Type resolveType(Type type, Type srcType, Class&lt;?&gt; declaringClass) &#123; if (type instanceof TypeVariable) &#123; return resolveTypeVar((TypeVariable&lt;?&gt;) type, srcType, declaringClass); &#125; else if (type instanceof ParameterizedType) &#123; return resolveParameterizedType((ParameterizedType) type, srcType, declaringClass); &#125; else if (type instanceof GenericArrayType) &#123; return resolveGenericArrayType((GenericArrayType) type, srcType, declaringClass); &#125; else &#123; return type; &#125;&#125; 回到MethodSignature的构造方法，除了设置返回类型以外，还设置了其他属性，详见注释 123456789101112131415161718192021222324MethodSignaturepublic MethodSignature(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method) &#123; ... // 是否返回void this.returnsVoid = void.class.equals(this.returnType); // 是否返回值有多个 this.returnsMany = configuration.getObjectFactory().isCollection(this.returnType) || this.returnType.isArray(); // 是否返回游标 this.returnsCursor = Cursor.class.equals(this.returnType); // 是否返回Optional this.returnsOptional = Optional.class.equals(this.returnType); // @MapKey注解中的返回Map类型的key值 this.mapKey = getMapKey(method); // 是否返回Map this.returnsMap = this.mapKey != null; // RowBounds类型在方法参数列表的位置 this.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class); // ResultHandler类型在方法参数列表的位置 this.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class); // 参数解析器，构造器中，如果有参数有@Param修饰，那么参数名取注解中的value值，否则直接取声明的参数名字 // 最后这些参数名会放入到SortedMap中（key是参数位置） this.paramNameResolver = new ParamNameResolver(configuration, method);&#125; MapperMethod就这么被构造完成了，那么就可以执行了，执行的时候调用的是execute方法，可以看到，该方法会根据前面的SqlCommand的类型来决定如何执行，而实际的执行是调用SqlSession的增删改查方法（还记得开头说的两种调用方式吗，本质来说是一种），这里面，比较复杂的是select，这个会最后说。这里增删改查的所有步骤都会包含convertArgsToSqlCommandParam这样一个过程，刚才ParamNameResolver的构造器实际上已经将方法参数转化为一个Map，这里是针对不同情况分别转化（参数为空返回null，只有一个参数，那么直接返回参数值，否则会返回一个ParamMap，key是参数名，value是参数值，不仅如此，这个Map里面还加入了普通参数名，即key为param1，param2…value为参数值） 123456789101112131415161718192021222324MapperMethodpublic Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; switch (command.getType()) &#123; case INSERT: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); break; &#125; case UPDATE: &#123; ... &#125; case DELETE: &#123; ... &#125; case SELECT: &#123; ... &#125; case FLUSH: &#123; ... &#125; &#125;&#125; 现在正式进入到具体的执行方法中，首先看insert，跳进去可以发现，insert其实是调用的update，而一切的一切，最终的执行都是落在Executor上。 123456789101112DefaultSqlSession@Overridepublic int insert(String statement, Object parameter) &#123; return update(statement, parameter);&#125;@Overridepublic int update(String statement, Object parameter) &#123; MappedStatement ms = configuration.getMappedStatement(statement); return executor.update(ms, wrapCollection(parameter));&#125; 前面有提到过，Executor的构造是通过ExecutorType来选择的，实际上不同的Executor只是在BaseExecutor的基础上继承重写。BaseExecutor是一个模版类，定了update，query等方法，而真正的实现（doUpdate，doQuery）是抽象方法，委托给子类，我们这里讨论SimpleExecutor的实现 可以看出，执行的时候需要的两个最重要元素：MappedStatement（初始化的时候已经注册，此时直接取出即可），StatementHandler。StatementHandler负责产生出Statement（JDBC规范）以及执行Statement。这个时候我们的sql就被执行完成了。 12345678910111213141516BaseExectutorpublic int update(MappedStatement ms, Object parameter) throws SQLException &#123; clearLocalCache(); return doUpdate(ms, parameter);&#125;SimpleExecutor@Overridepublic int doUpdate(MappedStatement ms, Object parameter) throws SQLException &#123; Configuration configuration = ms.getConfiguration(); StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null); Statement stmt = prepareStatement(handler, ms.getStatementLog()); return handler.update(stmt);&#125; 上述过程还有很多地方没有被挖掘到，我们会在后面的章节继续分析。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mybatis","slug":"技术/mybatis","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"}],"tags":[]},{"title":"Mybatis是如何生成SqlMapper的","slug":"Mybatis是如何生成sqlMapper的","date":"2019-12-29T14:57:00.000Z","updated":"2020-03-04T08:05:35.301Z","comments":true,"path":"2019/12/29/Mybatis是如何生成sqlMapper的/","link":"","permalink":"http://yoursite.com/2019/12/29/Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90sqlMapper%E7%9A%84/","excerpt":"","text":"mybatis 3.5.4 着重讨论一下通过注解，interface上面的sql语句是怎么一步一步被解析最终能够执行的。 首先，mybatis所有声明的sql到mapper的转化都是在初始化阶段完成的。mybatis的执行入口是SqlSession，SqlSession由SqlSessionFactory这个工厂类创建，而SqlSessionFactory是由SqlSessionFactoryBuilder的build方法产生的。 细看该方法（截取部分）： 123456SqlSessionFactoryBuilderpublic SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; 实际上，第4行的parser.parse()返回的对象是Configuration，这也是mybatis的核心对像。进入到parse()方法，再进到parseConfiguration方法，可以看到他是对xml中的configuration节点进行解析，并且设置数据到对象中此时，我们关心的关键来了 – mapperElement，跳进去 方法还是比较长的，我们挑重点说：大意是遍历mappers节点的所有子节点，如果子节点是package，那么Configuration中添加包名，否则的话会把resource，url，class等标签拿出来，针对单个mapper做处理，我们先只看第一种情况，如何添加包名从而添加mapper 123456XMLConfigBuilderif (&quot;package&quot;.equals(child.getName())) &#123; String mapperPackage = child.getStringAttribute(&quot;name&quot;); configuration.addMappers(mapperPackage);&#125; 再进一步，跳进addMappers方法中，可以看出，所有的mapper类都是被添加到MapperRegistry这样的注册类中 12345Configurationpublic void addMappers(String packageName) &#123; mapperRegistry.addMappers(packageName);&#125; 继续跳进去，可以发现核心方法，这里借用了一个ResolverUtil的工具类，目的是为了找到包下面的所有class，这里的superType是Object整个方法作用是找到所有是superType子类的类。 12345678910MapperRegistrypublic void addMappers(String packageName, Class&lt;?&gt; superType) &#123; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses(); for (Class&lt;?&gt; mapperClass : mapperSet) &#123; addMapper(mapperClass); &#125;&#125; 先暂时不管类是怎么找出来的，将目光聚焦在addMapper方法上，主要过程如下，knownMapper，顾名思义是一个缓存，存储的是已知的Mapper，而且不是本身的Mapper类，而是代理的工厂类，我们通过注解方式声明的Mapper会通过该代理工厂最终会转化为代理的对象。 1234567MapperRegistrypublic &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123; knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type)); MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type); parser.parse();&#125; 继续，这里又产生了一个parser，它的主要用途是解析Mapper的方法上的注解，进入parse方法，可以看到该方法真正的对各种注解进行解析，parseCache解析的是@CacheNamespace，parseCacheRef解析的是@CacheNamespaceRef，这些是类级别的注解。而parseStatement就是解析方法级别的各种注解可以注意到，方法注解的解析只处理非”桥接”方法。（范型的继承和实现，在类型擦除的过程中，编译器会生成”桥接”方法，该方法实际是一个兼容性的方法，具体可阅读该文章 https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html） 1234567891011121314MapperAnnotationBuilderpublic void parse() &#123; loadXmlResource(); parseCache(); parseCacheRef(); Method[] methods = type.getMethods(); for (Method method : methods) &#123; if (!method.isBridge()) &#123; // issue #237 parseStatement(method); &#125; &#125;&#125; 依旧是关注代码主干，进入到parseStatement方法parseStatement做的事情还是比较多的，我们一步一步来分析 首先获取方法的参数类型，如果参数是多个，那么parameterTypeClass的值为ParamMap.class，同时会排除RowBounds和ResultHandler类型然后获取LanguageDriver，通过@Lang注解在Configuration中获得，LanguageDriver的主要用途是翻译sql，常见有xml，raw和velocity（实际上翻译sql的过程也是一个比较复杂而繁琐的，有机会以后会专门开设章节说说sql如何翻译出来的） 123456MapperAnnotationBuildervoid parseStatement(Method method) Class&lt;?&gt; parameterTypeClass = getParameterType(method); LanguageDriver languageDriver = getLanguageDriver(method); 接下来的方法，是通过上述信息，把方法注解中的sql语句转化为SqlSource对象，这里有个注意点，sql语句的提供不仅仅是增删改查那几个注解，还有对应的SqlProvider，该方法对这两种情况都做了相应的处理 12345MapperAnnotationBuildervoid parseStatement(Method method) SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver); 再然后，取出方法注解中的@Options中的各种属性（是否使用缓存，如何刷缓存，结果集类型，表达式（statement）类型，超时时间，是否使用key等等）如果有@SelectKey，那么会将其中sql解析出来，然后放入到configuration的mappedStatement中（这个后面还会说到），并生成SelectKeyGenerator同样注册到Configuration中。之后，如果有@ResultMap，那么解析相关注解 如果没有ResultMap，并且是一个查询方法，那么会自行解析一个result map，首先会寻找以下注解：@Arg，@Result，@TypeDiscriminator然后分别做解析操作，这里定义result map直接和查询的结果集与对象映射有关，并且会被加入到Configuration中，后面章节会重点讲解 1234567891011MapperAnnotationBuilderprivate String parseResultMap(Method method) &#123; Class&lt;?&gt; returnType = getReturnType(method); Arg[] args = method.getAnnotationsByType(Arg.class); Result[] results = method.getAnnotationsByType(Result.class); TypeDiscriminator typeDiscriminator = method.getAnnotation(TypeDiscriminator.class); String resultMapId = generateResultMapName(method); applyResultMap(resultMapId, returnType, args, results, typeDiscriminator); return resultMapId;&#125; 本方法的最后一行（好长….）,MapperBuilderAssistant会将Mapper方法上所有的有关信息汇总起来，封装成MappedStatement对象注册到Configuration中，换言之，Mapper方法上sql在mybatis的最终形态就是MappedStatement 123456789101112131415MapperAnnotationBuildervoid parseStatement(Method method)assistant.addMappedStatement(mappedStatementId, sqlSource, statementType, sqlCommandType, fetchSize, timeout, // ParameterMapID null, parameterTypeClass, resultMapId, getReturnType(method), resultSetType, flushCache, useCache, // TODO gcode issue #577 false, keyGenerator, keyProperty, keyColumn, // DatabaseID null, languageDriver, // ResultSets options != null ? nullOrEmpty(options.resultSets()) : null); 至此，回到我们的第一个代码片段，发现SqlSessionFactoryBuilder这个建造类已经将SqlSessionFactory建造出来了，那么这个时候就可以用建造出来的工厂类进一步产生SqlSession以执行相应的语句了。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mybatis","slug":"技术/mybatis","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mybatis/"}],"tags":[]},{"title":"uuid是如何生成的","slug":"uuid是如何生成的","date":"2019-11-18T12:00:00.000Z","updated":"2019-12-16T14:02:32.426Z","comments":true,"path":"2019/11/18/uuid是如何生成的/","link":"","permalink":"http://yoursite.com/2019/11/18/uuid%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mysql","slug":"技术/mysql","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mysql/"}],"tags":[]},{"title":"mysql对子查询的优化","slug":"mysql对子查询的优化","date":"2019-11-17T16:00:00.000Z","updated":"2020-01-05T04:13:09.550Z","comments":true,"path":"2019/11/18/mysql对子查询的优化/","link":"","permalink":"http://yoursite.com/2019/11/18/mysql%E5%AF%B9%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BC%98%E5%8C%96/","excerpt":"","text":"版本 mysql 8.0+ 参照mysql的官方说明手册，对于子查询（subqueries），优化器会采用如下策略： 针对in, = any, exists semijoin（半连接，针对in） Materialization（物化） exists 策略 针对not in, &lt;&gt; all, not exists Materialization（物化） exists 策略 那么什么是半连接呢？ 半连接和join类似，都是基于某些条件将两张表连接起来，但不同的是，半连接仅仅返回一张表的内容半连接最大的好处是减少冗余（想想join返回的是连接两张表之后的内容） 那么什么是物化呢？ 将子查询的结果保存为一张带有索引的临时表，后续查询时直接对临时表进行访问 半连接优化in和exists 半连接(semijoin)是一种准备时期的转换，这种转化将采用如下策略：表格剥离，冗余清除，首次匹配，松散扫描和物化 我们观察如下的sql 1234select class.class_num, class.class_namefrom classinner join rosterwhere class.class_num = roster.class_num 其中class_num为主键 可以看到，这是个join操作，但是仔细观察，我们发现需要返回的结果仅仅是class表的两列，那么这个join操作实际上是冗余的。于是，为了消除冗余，我们可以有如下的写法： 1234select class_num, class_namefrom classwhere class_num in (select class_num from roster) 这种情况下，返回值仅仅是一张表的某些字段，此时，mysql会使用semijoin在mysql中，还有一种antijoin，这是和semijoin相对的概念，简单来说，就是not in或者not exists要想使用半连接，是有一些前提条件的，比如：select中不能有union关键字不能有having不能包含聚合操作外部查询中不能使用STRAIGHT_JOIN的join类型 转化为semijoin的时候mysql会采用最开始说的那几种策略，现解释他们的意思： 将子查询转为join，”表格剥离”指将表从子查询中剥离出来和外部查询进行inner join 冗余清除指的是类似于join一样运行semijoin，然后用临时表去掉重复记录 “首次匹配”指只返回第一个符合条件的结果，而不是全部 “松散扫描”指利用索引在每个子查询中选择值 “物化”指将子查询转化为基于索引的临时表以进行下一步的join，而索引用作去重 物化法优化子查询exists策略优化子查询观察第二个sql，实际上，内部的class_num是外部class_num的条件（即这个class_num必须在roster表中），那么针对这样的子查询，优化器会将其转化为exists语句，也就是exists策略，如下： 1234select class_num, class_namefrom classwhere exists(select * from roster where class.class_num = roster.class_num) 那么exists的执行过程是如何的呢？由于连接的条件是两个class_num相等，那么在执行sql语句的时候首先会将class表中的class_num依次取出来，然后和内部子查询的roster的class_num做对比，如果相等，那么返回true(子查询返回true)，如果返回true，那么保留class那行的数据。这个时候我们可以想一下，假设class有M条数据，roster有N条数据。再假设class_num上没有索引，那么上述查询就会执行MxN次，效率极低。 exists策略遵循下面的模式： 123outer_expr in (select inner_expr from xxx where yyy)转化为exists (select 1 from xxx where outer_expr = inner_expr and yyy) 但是需要注意的是，上述优化能够成立的条件是outer_expr和inner_expr都不为空那么如果其中有null值会发生什么呢？（sql当中null被翻译为”未知的值”） outer_expr肯定不返回null但是inner_expr可能返回null那么优化器会将其优化为 1exists (select 1 from xxx where outer_expr = inner_expr or inner_expr is null and yyy) outer_expr返回null如果outer_expr是null，那么执行的时候就会是这样 1null in (select inner_expr from xxx where yyy) 这时就必须要执行一遍里面的select来看inner_expr产生的值上述语句翻译过来就是，当select出任意null值时，结果返回null；当没有select出值时，返回false 为什么null的判断不能放到子查询里面去？因为子查询是对xxx表的判断而不是对外面的表的判断 而如果outer_expr不是null，查询的时候遵照exists优化的策略进行相应转换 可以看出，null值会使得优化过程变得复杂甚至使得查询变慢。所以在子查询中，要尽量避免内外条件为null的情况","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"mysql","slug":"技术/mysql","permalink":"http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/mysql/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-11-09T02:18:27.202Z","updated":"2019-11-09T02:18:27.231Z","comments":true,"path":"2019/11/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/11/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"十一·日本东京（上）","slug":"十一·日本东京（上）","date":"2019-11-02T21:45:00.000Z","updated":"2020-01-04T12:14:04.843Z","comments":true,"path":"2019/11/03/十一·日本东京（上）/","link":"","permalink":"http://yoursite.com/2019/11/03/%E5%8D%81%E4%B8%80%C2%B7%E6%97%A5%E6%9C%AC%E4%B8%9C%E4%BA%AC%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"对于我这么宅的人来说，能够花大把的时间出去旅游是一个小概率事件 – 然而概率再小只要不是0也有发生的可能。去日本的想法是我的同事提出来的，当时我还不知道，那部新海诚的《你的名字》是他动力的来源。刚好从来没有出过国的我也需要感受一下不同的世界，于是，我们一拍即合。为了错开十一的高峰，我们选择提前4天过去（事实证明，这是多么正确的决定）。作为最代表日本的城市，东京也自然而然成为了我们的目的地。 准备工作那么去之前肯定是要做一波提前准备和攻略了。无非就是交通，住宿和钱的问题。 行首先是机票，飞东京的飞机有直飞和中转之分，中转一般来说会花费整个白天的时间，当然价格也更便宜，直飞的话可以在携程或者去哪儿选择打包出售的往返的航班（这里有一个非常坑爹的地方，一般这种打包出售的航班均为廉价航班，比如这次我们定的乐桃航空，那么这种打包的廉价航班的一些缺点就需要格外注意：首先是不支持退票，单程往返都不行，也就是说你不想坐这趟航班了，那么你买票的钱就一去不复返了。然后是无法进行托运，我们当时是每人只能带两个包，并且一个人的总重量最多7KG）。所以航班按需选择才不会吃亏。 住早已耳闻东京的消费是很高的，这一点尤其体现在酒店上面（稍微好点的酒店一晚上就是700+，对于要呆七天的我们来说根本伤不起）。所以民宿就是第一选择。在Airbnb上，根据游玩的地方选住处是不错的策略，住的话也比较推荐住三天及以上（因为这样可以分摊一大笔打扫费和其他费用）。总的来说，一个人大约三百就可以搞定了。我们三人根据路线定了目黑区和港区的民宿，民宿截图1民宿截图2 钱即便在东京，也有很多地方不支持信用卡消费（特别是拉面店），所以去之前还是要换购一些日元的，人命币比日元大概是1:15的样子，消费嘛… 一碗拉面大概1000+日元。另外，我不太建议消费的时候都用纸币，能用信用卡还是用信用卡，因为在日本找钱会找给你大量的硬币（硬币有500，200，100这些面额的你敢信），而硬币带回国内是不能换回人民币的。所以换汇按需操作，一天一人300人民币足矣。带回来的硬币 路线其实选择路线是个挺头疼的事情，毕竟第一次去一个完全陌生的城市。所以借鉴了各种大佬的攻略再结合时间安排我们选择了下面的路线图。东京路线 东京湾 东京塔 银座 新宿，歌舞伎町 皇居 上野公园，秋叶原 浅草寺，天空树大概就是这些地方，从下玩到上。后续会详聊。 出发9月27日，凌晨1点坐上乐桃航空，随着空乘甜美日语的语音播报，东京之行就这么开始了。 こんにちは、東京（你好，东京）落地东京凌晨4点，达到羽田空港，肝了小半个晚上的我们决定先从国际到达前往一号航站楼，然后在那里的胶囊旅馆补充电量。胶囊旅馆1小小的胶囊旅馆提供了浴室，到点了会有人过来敲门。胶囊旅馆2补充了随眠以及在机场全家吃了点午饭之后，开始赶往民宿。地铁票奇贵，这也是日本交通的一个特点，从机场到民宿的地方大概花了50人民币。（后来的时候买了一种三日通票很有效的缓解了压力）地铁通票另外需要吐槽的是，日本的地铁分为不同的公司运营，也就是说一个站内可能会有多家公司的地铁，转乘换乘要找半天。不过，吐槽归吐槽，东京虽然人多地方小，但是极其的有秩序，人们上电梯统一往左靠，给右边留出位置让其他人快速通行。所以乘地铁的时候是人多而不乱的感觉，这一点我真心感觉国内需要学学。透过轨道交通的窗户，第一次看到地表之上的东京。建筑大多都是浅色，白色，或者灰色，非常干净，天空湛蓝，几片厚实的云朵挂在天上，小小的街道，小小的房子，电线杆和电线错落有致，我突然感觉，漫画里的日本就是那个日本，新海诚的画风也恰恰只是还原了他心中的东京而已。目黑区民宿的主人之前有发过一些消息给我，当时没怎么看，下了地铁找民宿的时候打开，竟然是非常非常详细的指南，详细到遇到什么建筑，该往哪里拐，直走一直看到什么再右拐，到达之后什么地方有什么之类的都写的清清楚楚。以图为证。民宿消息第一家民宿还是非常令人满意的，是一家人别墅中的一个房间，位于安静的小巷中，小巷里有有一个坡，叫做”猫坡”。民宿1民宿2民宿3民宿4猫坡 夜晚东京下午三点民宿才开。到了之后自然先补觉，睡地上远远比睡床上舒服～没想到第一次真正近距离的接触东京是在晚上，在中目黑。东京比上海要早一个小时，因此晚上黑的特别快，夜幕下，宽阔的主干道布满了密集而匆匆的行人，上面是偶尔呼啸而过的地铁，周围的小巷里是明亮又精致小巧的店铺。饿了，赶紧找吃的。找店铺就像找男女朋友一样，当前的已经挺好了，却还是希望前面能够有更好的。于是在逛遍几乎整个目黑地铁站附近的商圈后，回头找了一家烧鸟店。一个帅气的日本小哥在吧台的中间现点现烤，即使是英文的菜单，也有很多令人摸不着头脑。于是，本着都试一试的心态再结合粗大的英语技巧，点了烤鸡大腿肉，烤鸡心，烤蔬菜什么的。烤肉是半生的，没有腥味，蘸上芥末口感绵柔。值得一提的是，烤的一朵香菇出奇的好吃，入口有淡淡的奶香。烧鸟店1烧鸟店2在东京，吃的大多要么是传统日式料理（寿司，刺身，拉面），要么是那种结合洋快餐的混搭风（炸鸡，牛排，面包）。酒足饭饱之后自然以闲逛结束疲惫的一天。路上还是非常宁静的，默默行走，但是店内却是另一翻热闹的景象，觥筹交错。在负一楼的地方还有一家叫做”女豹”的店，大概就是穿着暴露的服务小姐陪客人喝酒聊天。anyway，日本之行就这么开始了😃","categories":[{"name":"旅行","slug":"旅行","permalink":"http://yoursite.com/categories/%E6%97%85%E8%A1%8C/"}],"tags":[]},{"title":"十月·收获与开始","slug":"十月·收获与开始","date":"2019-10-27T21:45:00.000Z","updated":"2019-12-07T08:35:57.551Z","comments":true,"path":"2019/10/28/十月·收获与开始/","link":"","permalink":"http://yoursite.com/2019/10/28/%E5%8D%81%E6%9C%88%C2%B7%E6%94%B6%E8%8E%B7%E4%B8%8E%E5%BC%80%E5%A7%8B/","excerpt":"","text":"毕业这两年2017年本科学位软件工程专业毕业的我带着无数的好奇和憧憬来到上海，加入了一家银行的研发中心。对于一个初出茅庐，刚刚踏入社会的青年来说，一切都是崭新的，一切都是值得探索的，人生的帆船正由自己掌舵，向梦想航行。毕业那年，我都还没满22。但是过来的我们都知道，半年的热情始终会被社会的洪流冷却。这个时候我才明白，一个人在社会中可以如此渺小。走下的地铁，望着穿梭的人群，甚至感觉我好像不属于这里。于是也明白了什么是”哀吾生之须臾，羡长江之无穷”。一个刚毕业不久没啥钱的愣头青什么也做不了。所以，能怎么办？学习，发展，积蓄力量，让自己更加强大。做一个专注的人，做一个纯粹的人，做一个摆脱懒惰的人，做一个抵抗得住诱惑的人。 人嘛，别安于现状。 我知道现阶段的公司肯定不是我的目标，我希望能够更好！于是每天下班回家的事情就是学习，啃书，周末的时间就是刷题，锻炼。弹指一挥间，从本科毕业到现在已经工作了两年的时间。这两年过的不算精彩，但也还充实。没有像同龄人那样能够在该放肆的年纪大胆的去放肆，也没能够有一段轰轰烈烈，精精彩彩的恋爱经历。经常羡慕那些结伴出去玩耍的小伙伴，每到一个适宜旅游的时间段，朋友圈就变成了环球旅行展了，真的让人感慨不已。两年独自战斗还是很寂寞的，没人可以一起讨论，没人可以帮你，为了不那么无聊，这期间还开了个淘宝店，顺便学了下ps（偷笑）。但无论如何，我明白，革命还未成功，同志仍需努力。这两年我把能够读的和开发相关的书都过了一边（我是学Java的，所以这些书你懂的），读了Spring的核心源码，读了Netty的源码，读了N本《深入理解XXX》，刷了250道leetcode。为的是能够在一个合适的时间点更上一层楼！ 迷茫中碰撞俗话说”成功是留给有准备的人的”，然而，同样有一句话叫做”成功需要一定的机遇”。 成功需要一定机遇，但前提是你一定要准备。 实际上，在面试其他公司的时候并不是那么一帆风顺。从今年年初开始，我就开始尝试面试各个互联网公司，无一不是以失败告终，大多数都是一面游。确实，互联网行业的技术和金融行业的技术存在不小的鸿沟，我不是在比较技术的优劣，而是想说，要想进入到互联网行业就必须懂得行业的”规矩”，行业需要什么就准备什么。这方面，我还真的是吃过亏。当然了，无论做什么，失败总是总结的最好契机，从每个失败的面试中查漏补缺使我能够快速的知道我缺什么。然后花时间补回来。在我比较满意的面试结果之前，有不下十次的失败面试。也很感慨现在的要求确实越来越高了。而且一次成功的面试还和是否”口径相对”有关。假如说你是开发专长的，去面试的时候岗位是算法方向。那么失败也是必然的。所以也就印证了开头那句话：”成功需要一定的机遇”。 屡败屡战，终获硕果今年的九月，在无数次失败和打击的铺垫下，一路过关斩将，拿到4家公司的offer。每次面试，都是从晚上7点一直聊到10点，从造螺丝，到造轮子，再到造火箭。很多人说：面试造火箭，工作拧螺丝。是的，现实可能就是这样。但别忘了，即便只有百分之十真正在被使用，但剩下那百分之九十就是你行而别人不行的重要体现，也是能够给你更高酬劳的重要体现。 体现你价值的，是那90% 新的开始九月的成功面试让我觉得我这两年的心血没有白费。那颗两年前放在心头的石头也被暂时放下。入职之前顺便去了趟东京了却出国的心愿（开心）。这次也是玩的最开心的一次。也明白了苦尽甘来的意义。这个强者遍地的时代，”小目标”的实现也需要大力气。入职新公司，大家都年轻且聪明，有人只用了三年时间便连升三级，每个人干劲十足，业务和技术框架迭代迅速。挑战很大，机遇很大，”肝”是必须的。人生的波澜壮阔是因为我们主动去迎接一波接一波的挑战，冲破一个又一个大风大浪，逐渐达到胜利的彼岸。","categories":[{"name":"感悟","slug":"感悟","permalink":"http://yoursite.com/categories/%E6%84%9F%E6%82%9F/"}],"tags":[]}]}